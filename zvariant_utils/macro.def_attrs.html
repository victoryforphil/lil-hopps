<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Generates one or more structures used for parsing attributes in proc macros."><title>def_attrs in zvariant_utils - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zvariant_utils" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../zvariant_utils/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../zvariant_utils/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In zvariant_utils</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="index.html">zvariant_utils</a>::<wbr><a class="macro" href="#">def_attrs</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/zvariant_utils/macros.rs.html#247-492">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><span class="macro">macro_rules! </span>def_attrs {
    (@attr_ty str) =&gt; { ... };
    (@attr_ty bool) =&gt; { ... };
    (@attr_ty [str]) =&gt; { ... };
    (@attr_ty none) =&gt; { ... };
    (@attr_ty {
        $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
        <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) {
            $(<span class="macro-nonterminal">$attr_name</span>:ident <span class="macro-nonterminal">$kind</span>:tt),+
        }
    }) =&gt; { ... };
    (@match_attr_with <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident, <span class="macro-nonterminal">$matched</span>:expr) =&gt; { ... };
    (@match_attr str <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@match_attr bool <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@match_attr [str] <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@match_attr none <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@match_attr {
        $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
        <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) <span class="macro-nonterminal">$body</span>:tt
    } <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:expr, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@def_ty <span class="macro-nonterminal">$list_name</span>:ident str) =&gt; { ... };
    (@def_ty <span class="macro-nonterminal">$list_name</span>:ident bool) =&gt; { ... };
    (@def_ty <span class="macro-nonterminal">$list_name</span>:ident [str]) =&gt; { ... };
    (@def_ty <span class="macro-nonterminal">$list_name</span>:ident none) =&gt; { ... };
    (
        @def_ty <span class="macro-nonterminal">$list_name</span>:ident {
            $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
            <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) {
                $(<span class="macro-nonterminal">$attr_name</span>:ident <span class="macro-nonterminal">$kind</span>:tt),+
            }
        }
    ) =&gt; { ... };
    (
        @def_struct
        <span class="macro-nonterminal">$list_name</span>:ident
        $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
        <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) {
            $(<span class="macro-nonterminal">$attr_name</span>:ident <span class="macro-nonterminal">$kind</span>:tt),+
        }
    ) =&gt; { ... };
    (
        <span class="kw">crate </span><span class="macro-nonterminal">$list_name</span>:ident;
        $(
            $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
            <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) {
                $(<span class="macro-nonterminal">$attr_name</span>:ident <span class="macro-nonterminal">$kind</span>:tt),+
            }
        );+;
    ) =&gt; { ... };
}</pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Generates one or more structures used for parsing attributes in proc macros.</p>
<p>Generated structures have one static method called parse that accepts a slice of <a href="https://docs.rs/syn/1.0.109/syn/attr/struct.Attribute.html" title="struct syn::attr::Attribute"><code>Attribute</code></a>s.
The method finds attributes that contain meta lists (look like <code>#[your_custom_ident(...)]</code>) and
fills a newly allocated structure with values of the attributes if any.</p>
<p>The expected input looks as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">def_attrs! </span>{
    <span class="kw">crate </span>zvariant;

    <span class="doccomment">/// A comment.
    </span><span class="kw">pub </span>StructAttributes(<span class="string">&quot;struct&quot;</span>) { foo str, bar str, baz none };
    <span class="attr">#[derive(Hash)]
    </span>FieldAttributes(<span class="string">&quot;field&quot;</span>) { field_attr bool };
}</code></pre></div>
<p>Here we see multiple entries: an entry for an attributes group called <code>StructAttributes</code> and
another one for <code>FieldAttributes</code>. The former has three defined attributes: <code>foo</code>, <code>bar</code> and
<code>baz</code>. The generated structures will look like this in that case:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// A comment.
</span><span class="attr">#[derive(Default, Clone, Debug)]
</span><span class="kw">pub struct </span>StructAttributes {
    foo: <span class="prelude-ty">Option</span>&lt;String&gt;,
    bar: <span class="prelude-ty">Option</span>&lt;String&gt;,
    baz: bool,
}

<span class="attr">#[derive(Hash)]
#[derive(Default, Clone, Debug)]
</span><span class="kw">struct </span>FieldAttributes {
    field_attr: <span class="prelude-ty">Option</span>&lt;bool&gt;,
}</code></pre></div>
<p><code>foo</code> and <code>bar</code> attributes got translated to fields with <code>Option&lt;String&gt;</code> type which contain the
value of the attribute when one is specified. They are marked with <code>str</code> keyword which stands
for string literals. The <code>baz</code> attribute, on the other hand, has <code>bool</code> type because it’s an
attribute without value marked by the <code>none</code> keyword.</p>
<p>Currently the following literals are supported:</p>
<ul>
<li><code>str</code> - string literals;</li>
<li><code>bool</code> - boolean literals;</li>
<li><code>[str]</code> - lists of string literals (<code>#[macro_name(foo(&quot;bar&quot;, &quot;baz&quot;))]</code>);</li>
<li><code>none</code> - no literal at all, the attribute is specified alone.</li>
</ul>
<p>The strings between braces are embedded into error messages produced when an attribute defined
for one attribute group is used on another group where it is not defined. For example, if the
<code>field_attr</code> attribute was encountered by the generated <code>StructAttributes::parse</code> method, the
error message would say that it “is not allowed on structs”.</p>
<h2 id="nested-attribute-lists"><a href="#nested-attribute-lists">Nested attribute lists</a></h2>
<p>It is possible to create nested lists for specific attributes. This is done as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">def_attrs! </span>{
    <span class="kw">crate </span>zvariant;

    <span class="kw">pub </span>OuterAttributes(<span class="string">&quot;outer&quot;</span>) {
        simple_attr bool,
        nested_attr {
            <span class="doccomment">/// An example of nested attributes.
            </span><span class="kw">pub </span>InnerAttributes(<span class="string">&quot;inner&quot;</span>) {
                inner_attr str
            }
        }
    };
}</code></pre></div>
<p>The syntax for inner attributes is the same as for the outer attributes, but you can specify
only one inner attribute per outer attribute.</p>
<h2 id="calling-the-macro-multiple-times"><a href="#calling-the-macro-multiple-times">Calling the macro multiple times</a></h2>
<p>The macro generates an array called <code>ALLOWED_ATTRS</code> that contains a list of allowed attributes.
Calling the macro twice in the same scope will cause a name alias and thus will fail to compile.
You need to place each macro invocation into a module in that case.</p>
<h2 id="errors"><a href="#errors">Errors</a></h2>
<p>The generated parse method checks for some error conditions:</p>
<ol>
<li>Unknown attributes. When multiple attribute groups are defined in the same macro invocation,
one gets a different error message when providing an attribute from a different attribute group.</li>
<li>Duplicate attributes.</li>
<li>Missing attribute value or present attribute value when none is expected.</li>
<li>Invalid literal type for attributes with values.</li>
</ol>
</div></details></section></div></main></body></html>