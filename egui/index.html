<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`egui`:  an easy-to-use GUI in pure Rust!"><title>egui - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="egui" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.1 (a28077b28 2023-12-04)" data-channel="1.74.1" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../egui/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../egui/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate egui</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.23.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">egui</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/egui/lib.rs.html#1-656">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>egui</code>:  an easy-to-use GUI in pure Rust!</p>
<p>Try the live web demo: <a href="https://www.egui.rs/#demo">https://www.egui.rs/#demo</a>. Read more about egui at <a href="https://github.com/emilk/egui">https://github.com/emilk/egui</a>.</p>
<p><code>egui</code> is in heavy development, with each new version having breaking changes.
You need to have rust 1.62.0 or later to use <code>egui</code>.</p>
<p>To quickly get started with egui, you can take a look at <a href="https://github.com/emilk/eframe_template"><code>eframe_template</code></a>
which uses <a href="https://docs.rs/eframe"><code>eframe</code></a>.</p>
<p>To create a GUI using egui you first need a <a href="struct.Context.html" title="struct egui::Context"><code>Context</code></a> (by convention referred to by <code>ctx</code>).
Then you add a <a href="containers/struct.Window.html" title="struct egui::containers::Window"><code>Window</code></a> or a <a href="containers/panel/struct.SidePanel.html" title="struct egui::containers::panel::SidePanel"><code>SidePanel</code></a> to get a <a href="struct.Ui.html" title="struct egui::Ui"><code>Ui</code></a>, which is what youâ€™ll be using to add all the buttons and labels that you need.</p>
<h3 id="feature-flags"><a href="#feature-flags">Feature flags</a></h3><h2 id="using-egui"><a href="#using-egui">Using egui</a></h2>
<p>To see what is possible to build with egui you can check out the online demo at <a href="https://www.egui.rs/#demo">https://www.egui.rs/#demo</a>.</p>
<p>If you like the â€œlearning by doingâ€ approach, clone <a href="https://github.com/emilk/eframe_template">https://github.com/emilk/eframe_template</a> and get started using egui right away.</p>
<h4 id="a-simple-example"><a href="#a-simple-example">A simple example</a></h4>
<p>Here is a simple counter that can be incremented and decremented using two buttons:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>ui_counter(ui: <span class="kw-2">&amp;mut </span>egui::Ui, counter: <span class="kw-2">&amp;mut </span>i32) {
    <span class="comment">// Put the buttons and label on the same row:
    </span>ui.horizontal(|ui| {
        <span class="kw">if </span>ui.button(<span class="string">&quot;âˆ’&quot;</span>).clicked() {
            <span class="kw-2">*</span>counter -= <span class="number">1</span>;
        }
        ui.label(counter.to_string());
        <span class="kw">if </span>ui.button(<span class="string">&quot;+&quot;</span>).clicked() {
            <span class="kw-2">*</span>counter += <span class="number">1</span>;
        }
    });
}</code></pre></div>
<p>In some GUI frameworks this would require defining multiple types and functions with callbacks or message handlers,
but thanks to <code>egui</code> being immediate mode everything is one self-contained function!</p>
<h4 id="getting-a-ui"><a href="#getting-a-ui">Getting a <code>Ui</code></a></h4>
<p>Use one of <a href="containers/panel/struct.SidePanel.html" title="struct egui::containers::panel::SidePanel"><code>SidePanel</code></a>, <a href="containers/panel/struct.TopBottomPanel.html" title="struct egui::containers::panel::TopBottomPanel"><code>TopBottomPanel</code></a>, <a href="containers/panel/struct.CentralPanel.html" title="struct egui::containers::panel::CentralPanel"><code>CentralPanel</code></a>, <a href="containers/struct.Window.html" title="struct egui::containers::Window"><code>Window</code></a> or <a href="containers/struct.Area.html" title="struct egui::containers::Area"><code>Area</code></a> to
get access to an <a href="struct.Ui.html" title="struct egui::Ui"><code>Ui</code></a> where you can put widgets. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>egui::CentralPanel::default().show(<span class="kw-2">&amp;</span>ctx, |ui| {
    ui.add(egui::Label::new(<span class="string">&quot;Hello World!&quot;</span>));
    ui.label(<span class="string">&quot;A shorter and more convenient way to add a label.&quot;</span>);
    <span class="kw">if </span>ui.button(<span class="string">&quot;Click me&quot;</span>).clicked() {
        <span class="comment">// take some action here
    </span>}
});</code></pre></div>
<h4 id="quick-start"><a href="#quick-start">Quick start</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.label(<span class="string">&quot;This is a label&quot;</span>);
ui.hyperlink(<span class="string">&quot;https://github.com/emilk/egui&quot;</span>);
ui.text_edit_singleline(<span class="kw-2">&amp;mut </span>my_string);
<span class="kw">if </span>ui.button(<span class="string">&quot;Click me&quot;</span>).clicked() { }
ui.add(egui::Slider::new(<span class="kw-2">&amp;mut </span>my_f32, <span class="number">0.0</span>..=<span class="number">100.0</span>));
ui.add(egui::DragValue::new(<span class="kw-2">&amp;mut </span>my_f32));

ui.checkbox(<span class="kw-2">&amp;mut </span>my_boolean, <span class="string">&quot;Checkbox&quot;</span>);

<span class="attr">#[derive(PartialEq)]
</span><span class="kw">enum </span>Enum { First, Second, Third }
ui.horizontal(|ui| {
    ui.radio_value(<span class="kw-2">&amp;mut </span>my_enum, Enum::First, <span class="string">&quot;First&quot;</span>);
    ui.radio_value(<span class="kw-2">&amp;mut </span>my_enum, Enum::Second, <span class="string">&quot;Second&quot;</span>);
    ui.radio_value(<span class="kw-2">&amp;mut </span>my_enum, Enum::Third, <span class="string">&quot;Third&quot;</span>);
});

ui.separator();

ui.image((my_image, egui::Vec2::new(<span class="number">640.0</span>, <span class="number">480.0</span>)));

ui.collapsing(<span class="string">&quot;Click to see what is hidden!&quot;</span>, |ui| {
    ui.label(<span class="string">&quot;Not much, as it turns out&quot;</span>);
});</code></pre></div>
<h3 id="coordinate-system"><a href="#coordinate-system">Coordinate system</a></h3>
<p>The left-top corner of the screen is <code>(0.0, 0.0)</code>,
with X increasing to the right and Y increasing downwards.</p>
<p><code>egui</code> uses logical <em>points</em> as its coordinate system.
Those related to physical <em>pixels</em> by the <code>pixels_per_point</code> scale factor.
For example, a high-dpi screeen can have <code>pixels_per_point = 2.0</code>,
meaning there are two physical screen pixels for each logical point.</p>
<p>Angles are in radians, and are measured clockwise from the X-axis, which has angle=0.</p>
<h2 id="integrating-with-egui"><a href="#integrating-with-egui">Integrating with egui</a></h2>
<p>Most likely you are using an existing <code>egui</code> backend/integration such as <a href="https://docs.rs/eframe"><code>eframe</code></a>, <a href="https://docs.rs/bevy_egui"><code>bevy_egui</code></a>,
or <a href="https://github.com/not-fl3/egui-miniquad"><code>egui-miniquad</code></a>,
but if you want to integrate <code>egui</code> into a new game engine or graphics backend, this is the section for you.</p>
<p>You need to collect <a href="struct.RawInput.html" title="struct egui::RawInput"><code>RawInput</code></a> and handle <a href="output/struct.FullOutput.html" title="struct egui::output::FullOutput"><code>FullOutput</code></a>. The basic structure is this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>ctx = egui::Context::default();

<span class="comment">// Game loop:
</span><span class="kw">loop </span>{
    <span class="kw">let </span>raw_input: egui::RawInput = gather_input();

    <span class="kw">let </span>full_output = ctx.run(raw_input, |ctx| {
        egui::CentralPanel::default().show(<span class="kw-2">&amp;</span>ctx, |ui| {
            ui.label(<span class="string">&quot;Hello world!&quot;</span>);
            <span class="kw">if </span>ui.button(<span class="string">&quot;Click me&quot;</span>).clicked() {
                <span class="comment">// take some action here
            </span>}
        });
    });
    handle_platform_output(full_output.platform_output);
    <span class="kw">let </span>clipped_primitives = ctx.tessellate(full_output.shapes); <span class="comment">// create triangles to paint
    </span>paint(full_output.textures_delta, clipped_primitives);
}</code></pre></div>
<p>For a reference OpenGL renderer, see <a href="https://github.com/emilk/egui/blob/master/crates/egui_glow/src/painter.rs">the <code>egui_glow</code> painter</a>.</p>
<h4 id="debugging-your-renderer"><a href="#debugging-your-renderer">Debugging your renderer</a></h4><h5 id="things-look-jagged"><a href="#things-look-jagged">Things look jagged</a></h5>
<ul>
<li>Turn off backface culling.</li>
</ul>
<h5 id="my-text-is-blurry"><a href="#my-text-is-blurry">My text is blurry</a></h5>
<ul>
<li>Make sure you set the proper <code>pixels_per_point</code> in the input to egui.</li>
<li>Make sure the texture sampler is not off by half a pixel. Try nearest-neighbor sampler to check.</li>
</ul>
<h5 id="my-windows-are-too-transparent-or-too-dark"><a href="#my-windows-are-too-transparent-or-too-dark">My windows are too transparent or too dark</a></h5>
<ul>
<li>egui uses premultiplied alpha, so make sure your blending function is <code>(ONE, ONE_MINUS_SRC_ALPHA)</code>.</li>
<li>Make sure your texture sampler is clamped (<code>GL_CLAMP_TO_EDGE</code>).</li>
<li>egui prefers linear color spaces for all blending so:
<ul>
<li>Use an sRGBA-aware texture if available (e.g. <code>GL_SRGB8_ALPHA8</code>).
<ul>
<li>Otherwise: remember to decode gamma in the fragment shader.</li>
</ul>
</li>
<li>Decode the gamma of the incoming vertex colors in your vertex shader.</li>
<li>Turn on sRGBA/linear framebuffer if available (<code>GL_FRAMEBUFFER_SRGB</code>).
<ul>
<li>Otherwise: gamma-encode the colors before you write them again.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="understanding-immediate-mode"><a href="#understanding-immediate-mode">Understanding immediate mode</a></h2>
<p><code>egui</code> is an immediate mode GUI library.</p>
<p>Immediate mode has its roots in gaming, where everything on the screen is painted at the
display refresh rate, i.e. at 60+ frames per second.
In immediate mode GUIs, the entire interface is laid out and painted at the same high rate.
This makes immediate mode GUIs especially well suited for highly interactive applications.</p>
<p>It is useful to fully grok what â€œimmediate modeâ€ implies.</p>
<p>Here is an example to illustrate it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if </span>ui.button(<span class="string">&quot;click me&quot;</span>).clicked() {
    take_action()
}</code></pre></div>
<p>This code is being executed each frame at maybe 60 frames per second.
Each frame egui does these things:</p>
<ul>
<li>lays out the letters <code>click me</code> in order to figure out the size of the button</li>
<li>decides where on screen to place the button</li>
<li>check if the mouse is hovering or clicking that location</li>
<li>chose button colors based on if it is being hovered or clicked</li>
<li>add a <a href="enum.Shape.html#variant.Rect" title="variant egui::Shape::Rect"><code>Shape::Rect</code></a> and <a href="enum.Shape.html#variant.Text" title="variant egui::Shape::Text"><code>Shape::Text</code></a> to the list of shapes to be painted later this frame</li>
<li>return a <a href="struct.Response.html" title="struct egui::Response"><code>Response</code></a> with the <a href="struct.Response.html#method.clicked" title="method egui::Response::clicked"><code>clicked</code></a> member so the user can check for interactions</li>
</ul>
<p>There is no button being created and stored somewhere.
The only output of this call is some colored shapes, and a <a href="struct.Response.html" title="struct egui::Response"><code>Response</code></a>.</p>
<p>Similarly, consider this code:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.add(egui::Slider::new(<span class="kw-2">&amp;mut </span>value, <span class="number">0.0</span>..=<span class="number">100.0</span>).text(<span class="string">&quot;My value&quot;</span>));</code></pre></div>
<p>Here egui will read <code>value</code> (an <code>f32</code>) to display the slider, then look if the mouse is dragging the slider and if so change the <code>value</code>.
Note that <code>egui</code> does not store the slider value for you - it only displays the current value, and changes it
by how much the slider has been dragged in the previous few milliseconds.
This means it is responsibility of the egui user to store the state (<code>value</code>) so that it persists between frames.</p>
<p>It can be useful to read the code for the toggle switch example widget to get a better understanding
of how egui works: <a href="https://github.com/emilk/egui/blob/master/crates/egui_demo_lib/src/demo/toggle_switch.rs">https://github.com/emilk/egui/blob/master/crates/egui_demo_lib/src/demo/toggle_switch.rs</a>.</p>
<p>Read more about the pros and cons of immediate mode at <a href="https://github.com/emilk/egui#why-immediate-mode">https://github.com/emilk/egui#why-immediate-mode</a>.</p>
<h2 id="misc"><a href="#misc">Misc</a></h2><h3 id="how-widgets-works"><a href="#how-widgets-works">How widgets works</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if </span>ui.button(<span class="string">&quot;click me&quot;</span>).clicked() { take_action() }</code></pre></div>
<p>is short for</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>button = egui::Button::new(<span class="string">&quot;click me&quot;</span>);
<span class="kw">if </span>ui.add(button).clicked() { take_action() }</code></pre></div>
<p>which is short for</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>button = egui::Button::new(<span class="string">&quot;click me&quot;</span>);
<span class="kw">let </span>response = button.ui(ui);
<span class="kw">if </span>response.clicked() { take_action() }</code></pre></div>
<p><a href="widgets/struct.Button.html" title="struct egui::widgets::Button"><code>Button</code></a> uses the builder pattern to create the data required to show it. The <a href="widgets/struct.Button.html" title="struct egui::widgets::Button"><code>Button</code></a> is then discarded.</p>
<p><a href="widgets/struct.Button.html" title="struct egui::widgets::Button"><code>Button</code></a> implements <code>trait</code> <a href="widgets/trait.Widget.html" title="trait egui::widgets::Widget"><code>Widget</code></a>, which looks like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub trait </span>Widget {
    <span class="doccomment">/// Allocate space, interact, paint, and return a [`Response`].
    </span><span class="kw">fn </span>ui(<span class="self">self</span>, ui: <span class="kw-2">&amp;mut </span>Ui) -&gt; Response;
}</code></pre></div>
<h3 id="auto-sizing-panels-and-windows"><a href="#auto-sizing-panels-and-windows">Auto-sizing panels and windows</a></h3>
<p>In egui, all panels and windows auto-shrink to fit the content.
If the window or panel is also resizable, this can lead to a weird behavior
where you can drag the edge of the panel/window to make it larger, and
when you release the panel/window shrinks again.
This is an artifact of immediate mode, and here are some alternatives on how to avoid it:</p>
<ol>
<li>Turn off resizing with <a href="containers/struct.Window.html#method.resizable" title="method egui::containers::Window::resizable"><code>Window::resizable</code></a>, <a href="containers/panel/struct.SidePanel.html#method.resizable" title="method egui::containers::panel::SidePanel::resizable"><code>SidePanel::resizable</code></a>, <a href="containers/panel/struct.TopBottomPanel.html#method.resizable" title="method egui::containers::panel::TopBottomPanel::resizable"><code>TopBottomPanel::resizable</code></a>.</li>
<li>Wrap your panel contents in a <a href="containers/scroll_area/struct.ScrollArea.html" title="struct egui::containers::scroll_area::ScrollArea"><code>ScrollArea</code></a>, or use <a href="containers/struct.Window.html#method.vscroll" title="method egui::containers::Window::vscroll"><code>Window::vscroll</code></a> and <a href="containers/struct.Window.html#method.hscroll" title="method egui::containers::Window::hscroll"><code>Window::hscroll</code></a>.</li>
<li>Use a justified layout:</li>
</ol>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.with_layout(egui::Layout::top_down_justified(egui::Align::Center), |ui| {
    ui.button(<span class="string">&quot;I am becoming wider as needed&quot;</span>);
});</code></pre></div>
<ol start="4">
<li>Fill in extra space with emptiness:</li>
</ol>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.allocate_space(ui.available_size()); <span class="comment">// put this LAST in your panel/window code</span></code></pre></div>
<h3 id="sizes"><a href="#sizes">Sizes</a></h3>
<p>You can control the size of widgets using <a href="struct.Ui.html#method.add_sized" title="method egui::Ui::add_sized"><code>Ui::add_sized</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.add_sized([<span class="number">40.0</span>, <span class="number">20.0</span>], egui::DragValue::new(<span class="kw-2">&amp;mut </span>my_value));</code></pre></div>
<h3 id="code-snippets"><a href="#code-snippets">Code snippets</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Miscellaneous tips and tricks

</span>ui.horizontal_wrapped(|ui| {
    ui.spacing_mut().item_spacing.x = <span class="number">0.0</span>; <span class="comment">// remove spacing between widgets
    // `radio_value` also works for enums, integers, and more.
    </span>ui.radio_value(<span class="kw-2">&amp;mut </span>some_bool, <span class="bool-val">false</span>, <span class="string">&quot;Off&quot;</span>);
    ui.radio_value(<span class="kw-2">&amp;mut </span>some_bool, <span class="bool-val">true</span>, <span class="string">&quot;On&quot;</span>);
});

ui.group(|ui| {
    ui.label(<span class="string">&quot;Within a frame&quot;</span>);
    ui.set_min_height(<span class="number">200.0</span>);
});

<span class="comment">// A `scope` creates a temporary [`Ui`] in which you can change settings:
</span>ui.scope(|ui| {
    ui.visuals_mut().override_text_color = <span class="prelude-val">Some</span>(egui::Color32::RED);
    ui.style_mut().override_text_style = <span class="prelude-val">Some</span>(egui::TextStyle::Monospace);
    ui.style_mut().wrap = <span class="prelude-val">Some</span>(<span class="bool-val">false</span>);

    ui.label(<span class="string">&quot;This text will be red, monospace, and won&#39;t wrap to a new line&quot;</span>);
}); <span class="comment">// the temporary settings are reverted here</span></code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.LayerId"><code>pub use layers::<a class="struct" href="layers/struct.LayerId.html" title="struct egui::layers::LayerId">LayerId</a>;</code></div></li><li><div class="item-name" id="reexport.Order"><code>pub use layers::<a class="enum" href="layers/enum.Order.html" title="enum egui::layers::Order">Order</a>;</code></div></li><li><div class="item-name" id="reexport.SizeHint"><code>pub use load::<a class="enum" href="load/enum.SizeHint.html" title="enum egui::load::SizeHint">SizeHint</a>;</code></div></li><li><div class="item-name" id="reexport.FontSelection"><code>pub use style::<a class="enum" href="style/enum.FontSelection.html" title="enum egui::style::FontSelection">FontSelection</a>;</code></div></li><li><div class="item-name" id="reexport.Margin"><code>pub use style::<a class="struct" href="style/struct.Margin.html" title="struct egui::style::Margin">Margin</a>;</code></div></li><li><div class="item-name" id="reexport.Style"><code>pub use style::<a class="struct" href="style/struct.Style.html" title="struct egui::style::Style">Style</a>;</code></div></li><li><div class="item-name" id="reexport.TextStyle"><code>pub use style::<a class="enum" href="style/enum.TextStyle.html" title="enum egui::style::TextStyle">TextStyle</a>;</code></div></li><li><div class="item-name" id="reexport.Visuals"><code>pub use style::<a class="struct" href="style/struct.Visuals.html" title="struct egui::style::Visuals">Visuals</a>;</code></div></li><li><div class="item-name" id="reexport.RichText"><code>pub use widget_text::<a class="struct" href="widget_text/struct.RichText.html" title="struct egui::widget_text::RichText">RichText</a>;</code></div></li><li><div class="item-name" id="reexport.WidgetText"><code>pub use widget_text::<a class="enum" href="widget_text/enum.WidgetText.html" title="enum egui::widget_text::WidgetText">WidgetText</a>;</code></div></li><li><div class="item-name" id="reexport.accesskit"><code>pub use <a class="mod" href="../accesskit/index.html" title="mod accesskit">accesskit</a>;</code></div></li><li><div class="item-name" id="reexport.ahash"><code>pub use <a class="mod" href="../ahash/index.html" title="mod ahash">ahash</a>;</code></div></li><li><div class="item-name" id="reexport.epaint"><code>pub use <a class="mod" href="../epaint/index.html" title="mod epaint">epaint</a>;</code></div></li><li><div class="item-name" id="reexport.ecolor"><code>pub use epaint::<a class="mod" href="../ecolor/index.html" title="mod ecolor">ecolor</a>;</code></div></li><li><div class="item-name" id="reexport.emath"><code>pub use epaint::<a class="mod" href="../emath/index.html" title="mod emath">emath</a>;</code></div></li><li><div class="item-name"><code>pub use <a class="mod" href="containers/index.html" title="mod egui::containers">containers</a>::*;</code></div></li><li><div class="item-name"><code>pub use <a class="mod" href="widgets/index.html" title="mod egui::widgets">widgets</a>::*;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="containers/index.html" title="mod egui::containers">containers</a></div><div class="desc docblock-short">Containers are pieces of the UI which wraps other pieces of UI. Examples: <a href="containers/struct.Window.html" title="struct egui::containers::Window"><code>Window</code></a>, <a href="containers/scroll_area/struct.ScrollArea.html" title="struct egui::containers::scroll_area::ScrollArea"><code>ScrollArea</code></a>, <a href="containers/struct.Resize.html" title="struct egui::containers::Resize"><code>Resize</code></a>, <a href="containers/panel/struct.SidePanel.html" title="struct egui::containers::panel::SidePanel"><code>SidePanel</code></a>, etc.</div></li><li><div class="item-name"><a class="mod" href="gui_zoom/index.html" title="mod egui::gui_zoom">gui_zoom</a></div><div class="desc docblock-short">Helpers for zooming the whole GUI of an app (changing <a href="struct.Context.html#method.pixels_per_point" title="method egui::Context::pixels_per_point"><code>Context::pixels_per_point</code></a>.</div></li><li><div class="item-name"><a class="mod" href="introspection/index.html" title="mod egui::introspection">introspection</a></div><div class="desc docblock-short">Showing UI:s for egui/epaint types.</div></li><li><div class="item-name"><a class="mod" href="layers/index.html" title="mod egui::layers">layers</a></div><div class="desc docblock-short">Handles paint layers, i.e. how things
are sometimes painted behind or in front of other things.</div></li><li><div class="item-name"><a class="mod" href="load/index.html" title="mod egui::load">load</a></div><div class="desc docblock-short">Image loading</div></li><li><div class="item-name"><a class="mod" href="menu/index.html" title="mod egui::menu">menu</a></div><div class="desc docblock-short">Menu bar functionality (very basic so far).</div></li><li><div class="item-name"><a class="mod" href="mutex/index.html" title="mod egui::mutex">mutex</a></div><div class="desc docblock-short">Helper module that adds extra checks when the <code>deadlock_detection</code> feature is turned on.</div></li><li><div class="item-name"><a class="mod" href="os/index.html" title="mod egui::os">os</a></div></li><li><div class="item-name"><a class="mod" href="output/index.html" title="mod egui::output">output</a></div><div class="desc docblock-short">All the data egui returns to the backend at the end of each frame.</div></li><li><div class="item-name"><a class="mod" href="special_emojis/index.html" title="mod egui::special_emojis">special_emojis</a></div><div class="desc docblock-short">The default egui fonts supports around 1216 emojis in total.
Here are some of the most useful:
âˆâŠ—â—â˜â™ââ´âµâ¶â·
â©âªâ­â®â¸â¹âºâ– â–¶ğŸ“¾ğŸ”€ğŸ”ğŸ”ƒ
â˜€â˜â˜…â˜†â˜â˜‘â˜œâ˜â˜â˜Ÿâ›ƒâ›¶âœ”
â†ºâ†»âŸ²âŸ³â¬…â¡â¬†â¬‡â¬ˆâ¬‰â¬Šâ¬‹â¬Œâ¬â®¨â®©â®ªâ®«
â™¡
ğŸ“…ğŸ“†
ğŸ“ˆğŸ“‰ğŸ“Š
ğŸ“‹ğŸ“ŒğŸ“ğŸ“¤ğŸ“¥ğŸ”†
ğŸ”ˆğŸ”‰ğŸ”ŠğŸ”ğŸ”ğŸ”—ğŸ”˜
ğŸ•“ğŸ–§ğŸ–©ğŸ–®ğŸ–±ğŸ–´ğŸ–µğŸ–¼ğŸ—€ğŸ—ğŸ—‹ğŸ—ğŸ—‘ğŸ—™ğŸš«â“</div></li><li><div class="item-name"><a class="mod" href="style/index.html" title="mod egui::style">style</a></div><div class="desc docblock-short">egui theme (spacing, colors, etc).</div></li><li><div class="item-name"><a class="mod" href="text/index.html" title="mod egui::text">text</a></div></li><li><div class="item-name"><a class="mod" href="util/index.html" title="mod egui::util">util</a></div><div class="desc docblock-short">Miscellaneous tools used by the rest of egui.</div></li><li><div class="item-name"><a class="mod" href="widget_text/index.html" title="mod egui::widget_text">widget_text</a></div></li><li><div class="item-name"><a class="mod" href="widgets/index.html" title="mod egui::widgets">widgets</a></div><div class="desc docblock-short">Widgets are pieces of GUI such as <a href="widgets/struct.Label.html" title="struct egui::widgets::Label"><code>Label</code></a>, <a href="widgets/struct.Button.html" title="struct egui::widgets::Button"><code>Button</code></a>, <a href="widgets/struct.Slider.html" title="struct egui::widgets::Slider"><code>Slider</code></a> etc.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.egui_assert.html" title="macro egui::egui_assert">egui_assert</a></div><div class="desc docblock-short">An assert that is only active when <code>egui</code> is compiled with the <code>extra_asserts</code> feature
or with the <code>extra_debug_asserts</code> feature in debug builds.</div></li><li><div class="item-name"><a class="macro" href="macro.generate_loader_id.html" title="macro egui::generate_loader_id">generate_loader_id</a></div><div class="desc docblock-short">Used to get a unique ID when implementing one of the loader traits: <a href="load/trait.BytesLoader.html#tymethod.id" title="method egui::load::BytesLoader::id"><code>BytesLoader::id</code></a>, <a href="load/trait.ImageLoader.html#tymethod.id" title="method egui::load::ImageLoader::id"><code>ImageLoader::id</code></a>, and <a href="load/trait.TextureLoader.html#tymethod.id" title="method egui::load::TextureLoader::id"><code>TextureLoader::id</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.github_link_file.html" title="macro egui::github_link_file">github_link_file</a></div><div class="desc docblock-short">Create a <a href="widgets/struct.Hyperlink.html" title="struct egui::widgets::Hyperlink"><code>Hyperlink</code></a> to the current <a href="https://doc.rust-lang.org/1.74.1/core/macro.file.html" title="macro core::file"><code>file!()</code></a> on github.</div></li><li><div class="item-name"><a class="macro" href="macro.github_link_file_line.html" title="macro egui::github_link_file_line">github_link_file_line</a></div><div class="desc docblock-short">Create a <a href="widgets/struct.Hyperlink.html" title="struct egui::widgets::Hyperlink"><code>Hyperlink</code></a> to the current <a href="https://doc.rust-lang.org/1.74.1/core/macro.file.html" title="macro core::file"><code>file!()</code></a> (and line) on Github</div></li><li><div class="item-name"><a class="macro" href="macro.include_image.html" title="macro egui::include_image">include_image</a></div><div class="desc docblock-short">Include an image in the binary.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Align2.html" title="struct egui::Align2">Align2</a></div><div class="desc docblock-short">Two-dimension alignment, e.g. <a href="struct.Align2.html#associatedconstant.LEFT_TOP" title="associated constant egui::Align2::LEFT_TOP"><code>Align2::LEFT_TOP</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ClippedPrimitive.html" title="struct egui::ClippedPrimitive">ClippedPrimitive</a></div><div class="desc docblock-short">A <a href="struct.Mesh.html" title="struct egui::Mesh"><code>Mesh</code></a> or <a href="struct.PaintCallback.html" title="struct egui::PaintCallback"><code>PaintCallback</code></a> within a clip rectangle.</div></li><li><div class="item-name"><a class="struct" href="struct.Color32.html" title="struct egui::Color32">Color32</a></div><div class="desc docblock-short">This format is used for space-efficient color representation (32 bits).</div></li><li><div class="item-name"><a class="struct" href="struct.ColorImage.html" title="struct egui::ColorImage">ColorImage</a></div><div class="desc docblock-short">A 2D RGBA color image in RAM.</div></li><li><div class="item-name"><a class="struct" href="struct.Context.html" title="struct egui::Context">Context</a></div><div class="desc docblock-short">Your handle to egui.</div></li><li><div class="item-name"><a class="struct" href="struct.DroppedFile.html" title="struct egui::DroppedFile">DroppedFile</a></div><div class="desc docblock-short">A file dropped into egui.</div></li><li><div class="item-name"><a class="struct" href="struct.EventFilter.html" title="struct egui::EventFilter">EventFilter</a></div><div class="desc docblock-short">Controls which events that a focused widget will have exclusive access to.</div></li><li><div class="item-name"><a class="struct" href="struct.FontData.html" title="struct egui::FontData">FontData</a></div><div class="desc docblock-short">A <code>.ttf</code> or <code>.otf</code> file and a font face index.</div></li><li><div class="item-name"><a class="struct" href="struct.FontDefinitions.html" title="struct egui::FontDefinitions">FontDefinitions</a></div><div class="desc docblock-short">Describes the font data and the sizes to use.</div></li><li><div class="item-name"><a class="struct" href="struct.FontId.html" title="struct egui::FontId">FontId</a></div><div class="desc docblock-short">How to select a sized font.</div></li><li><div class="item-name"><a class="struct" href="struct.FontImage.html" title="struct egui::FontImage">FontImage</a></div><div class="desc docblock-short">A single-channel image designed for the font texture.</div></li><li><div class="item-name"><a class="struct" href="struct.FontTweak.html" title="struct egui::FontTweak">FontTweak</a></div><div class="desc docblock-short">Extra scale and vertical tweak to apply to all text of a certain font.</div></li><li><div class="item-name"><a class="struct" href="struct.FullOutput.html" title="struct egui::FullOutput">FullOutput</a></div><div class="desc docblock-short">What egui emits each frame from <a href="struct.Context.html#method.run" title="method egui::Context::run"><code>crate::Context::run</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Galley.html" title="struct egui::Galley">Galley</a></div><div class="desc docblock-short">Text that has been laid out, ready for painting.</div></li><li><div class="item-name"><a class="struct" href="struct.Grid.html" title="struct egui::Grid">Grid</a></div><div class="desc docblock-short">A simple grid layout.</div></li><li><div class="item-name"><a class="struct" href="struct.HoveredFile.html" title="struct egui::HoveredFile">HoveredFile</a></div><div class="desc docblock-short">A file about to be dropped into egui.</div></li><li><div class="item-name"><a class="struct" href="struct.Id.html" title="struct egui::Id">Id</a></div><div class="desc docblock-short">egui tracks widgets frame-to-frame using <a href="struct.Id.html" title="struct egui::Id"><code>Id</code></a>s.</div></li><li><div class="item-name"><a class="struct" href="struct.InnerResponse.html" title="struct egui::InnerResponse">InnerResponse</a></div><div class="desc docblock-short">Returned when we wrap some ui-code and want to return both
the results of the inner function and the ui as a whole, e.g.:</div></li><li><div class="item-name"><a class="struct" href="struct.InputState.html" title="struct egui::InputState">InputState</a></div><div class="desc docblock-short">Input state that egui updates each frame.</div></li><li><div class="item-name"><a class="struct" href="struct.KeyboardShortcut.html" title="struct egui::KeyboardShortcut">KeyboardShortcut</a></div><div class="desc docblock-short">A keyboard shortcut, e.g. <code>Ctrl+Alt+W</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Layout.html" title="struct egui::Layout">Layout</a></div><div class="desc docblock-short">The layout of a <a href="struct.Ui.html" title="struct egui::Ui"><code>Ui</code></a>, e.g. â€œvertical &amp; centeredâ€.</div></li><li><div class="item-name"><a class="struct" href="struct.Memory.html" title="struct egui::Memory">Memory</a></div><div class="desc docblock-short">The data that egui persists between frames.</div></li><li><div class="item-name"><a class="struct" href="struct.Mesh.html" title="struct egui::Mesh">Mesh</a></div><div class="desc docblock-short">Textured triangles in two dimensions.</div></li><li><div class="item-name"><a class="struct" href="struct.ModifierNames.html" title="struct egui::ModifierNames">ModifierNames</a></div><div class="desc docblock-short">Names of different modifier keys.</div></li><li><div class="item-name"><a class="struct" href="struct.Modifiers.html" title="struct egui::Modifiers">Modifiers</a></div><div class="desc docblock-short">State of the modifier keys. These must be fed to egui.</div></li><li><div class="item-name"><a class="struct" href="struct.MultiTouchInfo.html" title="struct egui::MultiTouchInfo">MultiTouchInfo</a></div><div class="desc docblock-short">All you probably need to know about a multi-touch gesture.</div></li><li><div class="item-name"><a class="struct" href="struct.OpenUrl.html" title="struct egui::OpenUrl">OpenUrl</a></div><div class="desc docblock-short">What URL to open, and how.</div></li><li><div class="item-name"><a class="struct" href="struct.Options.html" title="struct egui::Options">Options</a></div><div class="desc docblock-short">Some global options that you can read and write.</div></li><li><div class="item-name"><a class="struct" href="struct.PaintCallback.html" title="struct egui::PaintCallback">PaintCallback</a></div><div class="desc docblock-short">If you want to paint some 3D shapes inside an egui region, you can use this.</div></li><li><div class="item-name"><a class="struct" href="struct.PaintCallbackInfo.html" title="struct egui::PaintCallbackInfo">PaintCallbackInfo</a></div><div class="desc docblock-short">Information passed along with <a href="struct.PaintCallback.html" title="struct egui::PaintCallback"><code>PaintCallback</code></a> (<a href="enum.Shape.html#variant.Callback" title="variant egui::Shape::Callback"><code>Shape::Callback</code></a>).</div></li><li><div class="item-name"><a class="struct" href="struct.Painter.html" title="struct egui::Painter">Painter</a></div><div class="desc docblock-short">Helper to paint shapes and text to a specific region on a specific layer.</div></li><li><div class="item-name"><a class="struct" href="struct.PlatformOutput.html" title="struct egui::PlatformOutput">PlatformOutput</a></div><div class="desc docblock-short">The non-rendering part of what egui emits each frame.</div></li><li><div class="item-name"><a class="struct" href="struct.PointerState.html" title="struct egui::PointerState">PointerState</a></div><div class="desc docblock-short">Mouse or touch state.</div></li><li><div class="item-name"><a class="struct" href="struct.Pos2.html" title="struct egui::Pos2">Pos2</a></div><div class="desc docblock-short">A position on screen.</div></li><li><div class="item-name"><a class="struct" href="struct.Rangef.html" title="struct egui::Rangef">Rangef</a></div><div class="desc docblock-short">Includive range of floats, i.e. <code>min..=max</code>, but more ergonomic than <a href="https://doc.rust-lang.org/1.74.1/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive"><code>RangeInclusive</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RawInput.html" title="struct egui::RawInput">RawInput</a></div><div class="desc docblock-short">What the integrations provides to egui at the start of each frame.</div></li><li><div class="item-name"><a class="struct" href="struct.Rect.html" title="struct egui::Rect">Rect</a></div><div class="desc docblock-short">A rectangular region of space.</div></li><li><div class="item-name"><a class="struct" href="struct.RequestRepaintInfo.html" title="struct egui::RequestRepaintInfo">RequestRepaintInfo</a></div><div class="desc docblock-short">Information given to the backend about when it is time to repaint the ui.</div></li><li><div class="item-name"><a class="struct" href="struct.Response.html" title="struct egui::Response">Response</a></div><div class="desc docblock-short">The result of adding a widget to a <a href="struct.Ui.html" title="struct egui::Ui"><code>Ui</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Rgba.html" title="struct egui::Rgba">Rgba</a></div><div class="desc docblock-short">0-1 linear space <code>RGBA</code> color with premultiplied alpha.</div></li><li><div class="item-name"><a class="struct" href="struct.Rounding.html" title="struct egui::Rounding">Rounding</a></div><div class="desc docblock-short">How rounded the corners of things should be</div></li><li><div class="item-name"><a class="struct" href="struct.Sense.html" title="struct egui::Sense">Sense</a></div><div class="desc docblock-short">What sort of interaction is a widget sensitive to?</div></li><li><div class="item-name"><a class="struct" href="struct.Stroke.html" title="struct egui::Stroke">Stroke</a></div><div class="desc docblock-short">Describes the width and color of a line.</div></li><li><div class="item-name"><a class="struct" href="struct.TextFormat.html" title="struct egui::TextFormat">TextFormat</a></div><div class="desc docblock-short">Formatting option for a section of text.</div></li><li><div class="item-name"><a class="struct" href="struct.TextureHandle.html" title="struct egui::TextureHandle">TextureHandle</a></div><div class="desc docblock-short">Used to paint images.</div></li><li><div class="item-name"><a class="struct" href="struct.TextureOptions.html" title="struct egui::TextureOptions">TextureOptions</a></div><div class="desc docblock-short">How the texture texels are filtered.</div></li><li><div class="item-name"><a class="struct" href="struct.TexturesDelta.html" title="struct egui::TexturesDelta">TexturesDelta</a></div><div class="desc docblock-short">What has been allocated and freed during the last period.</div></li><li><div class="item-name"><a class="struct" href="struct.TouchDeviceId.html" title="struct egui::TouchDeviceId">TouchDeviceId</a></div><div class="desc docblock-short">this is a <code>u64</code> as values of this kind can always be obtained by hashing</div></li><li><div class="item-name"><a class="struct" href="struct.TouchId.html" title="struct egui::TouchId">TouchId</a></div><div class="desc docblock-short">Unique identification of a touch occurrence (finger or pen or â€¦).
A Touch ID is valid until the finger is lifted.
A new ID is used for the next touch.</div></li><li><div class="item-name"><a class="struct" href="struct.Ui.html" title="struct egui::Ui">Ui</a></div><div class="desc docblock-short">This is what you use to place widgets.</div></li><li><div class="item-name"><a class="struct" href="struct.Vec2.html" title="struct egui::Vec2">Vec2</a></div><div class="desc docblock-short">A vector has a direction and length.
A <a href="struct.Vec2.html" title="struct egui::Vec2"><code>Vec2</code></a> is often used to represent a size.</div></li><li><div class="item-name"><a class="struct" href="struct.WidgetInfo.html" title="struct egui::WidgetInfo">WidgetInfo</a></div><div class="desc docblock-short">Describes a widget such as a <a href="widgets/struct.Button.html" title="struct egui::widgets::Button"><code>crate::Button</code></a> or a <a href="widgets/text_edit/struct.TextEdit.html" title="struct egui::widgets::text_edit::TextEdit"><code>crate::TextEdit</code></a>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Align.html" title="enum egui::Align">Align</a></div><div class="desc docblock-short">left/center/right or top/center/bottom alignment for e.g. anchors and layouts.</div></li><li><div class="item-name"><a class="enum" href="enum.CursorIcon.html" title="enum egui::CursorIcon">CursorIcon</a></div><div class="desc docblock-short">A mouse cursor icon.</div></li><li><div class="item-name"><a class="enum" href="enum.Direction.html" title="enum egui::Direction">Direction</a></div><div class="desc docblock-short">Layout direction, one of <a href="enum.Direction.html#variant.LeftToRight" title="variant egui::Direction::LeftToRight"><code>LeftToRight</code></a>, <a href="enum.Direction.html#variant.RightToLeft" title="variant egui::Direction::RightToLeft"><code>RightToLeft</code></a>, <a href="enum.Direction.html#variant.TopDown" title="variant egui::Direction::TopDown"><code>TopDown</code></a>, <a href="enum.Direction.html#variant.BottomUp" title="variant egui::Direction::BottomUp"><code>BottomUp</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.Event.html" title="enum egui::Event">Event</a></div><div class="desc docblock-short">An input event generated by the integration.</div></li><li><div class="item-name"><a class="enum" href="enum.FontFamily.html" title="enum egui::FontFamily">FontFamily</a></div><div class="desc docblock-short">Font of unknown size.</div></li><li><div class="item-name"><a class="enum" href="enum.ImageData.html" title="enum egui::ImageData">ImageData</a></div><div class="desc docblock-short">An image stored in RAM.</div></li><li><div class="item-name"><a class="enum" href="enum.Key.html" title="enum egui::Key">Key</a></div><div class="desc docblock-short">Keyboard keys.</div></li><li><div class="item-name"><a class="enum" href="enum.MouseWheelUnit.html" title="enum egui::MouseWheelUnit">MouseWheelUnit</a></div><div class="desc docblock-short">The unit associated with the numeric value of a mouse wheel event</div></li><li><div class="item-name"><a class="enum" href="enum.PointerButton.html" title="enum egui::PointerButton">PointerButton</a></div><div class="desc docblock-short">Mouse button (or similar for touch input)</div></li><li><div class="item-name"><a class="enum" href="enum.Shape.html" title="enum egui::Shape">Shape</a></div><div class="desc docblock-short">A paint primitive such as a circle or a piece of text.
Coordinates are all screen space points (not physical pixels).</div></li><li><div class="item-name"><a class="enum" href="enum.TextureFilter.html" title="enum egui::TextureFilter">TextureFilter</a></div><div class="desc docblock-short">How the texture texels are filtered.</div></li><li><div class="item-name"><a class="enum" href="enum.TextureId.html" title="enum egui::TextureId">TextureId</a></div><div class="desc docblock-short">What texture to use in a <a href="struct.Mesh.html" title="struct egui::Mesh"><code>Mesh</code></a> mesh.</div></li><li><div class="item-name"><a class="enum" href="enum.TouchPhase.html" title="enum egui::TouchPhase">TouchPhase</a></div><div class="desc docblock-short">In what phase a touch event is in.</div></li><li><div class="item-name"><a class="enum" href="enum.UserAttentionType.html" title="enum egui::UserAttentionType">UserAttentionType</a></div><div class="desc docblock-short">Types of attention to request from a user when a native window is not in focus.</div></li><li><div class="item-name"><a class="enum" href="enum.WidgetType.html" title="enum egui::WidgetType">WidgetType</a></div><div class="desc docblock-short">The different types of built-in widgets in egui</div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.NUM_POINTER_BUTTONS.html" title="constant egui::NUM_POINTER_BUTTONS">NUM_POINTER_BUTTONS</a></div><div class="desc docblock-short">Number of pointer buttons supported by egui, i.e. the number of possible states of <a href="enum.PointerButton.html" title="enum egui::PointerButton"><code>PointerButton</code></a>.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.NumExt.html" title="trait egui::NumExt">NumExt</a></div><div class="desc docblock-short">Extends <code>f32</code>, <a href="struct.Vec2.html" title="struct egui::Vec2"><code>Vec2</code></a> etc with <code>at_least</code> and <code>at_most</code> as aliases for <code>max</code> and <code>min</code>.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.__run_test_ctx.html" title="fn egui::__run_test_ctx">__run_test_ctx</a></div><div class="desc docblock-short">For use in tests; especially doctests.</div></li><li><div class="item-name"><a class="fn" href="fn.__run_test_ui.html" title="fn egui::__run_test_ui">__run_test_ui</a></div><div class="desc docblock-short">For use in tests; especially doctests.</div></li><li><div class="item-name"><a class="fn" href="fn.accesskit_root_id.html" title="fn egui::accesskit_root_id">accesskit_root_id</a></div></li><li><div class="item-name"><a class="fn" href="fn.lerp.html" title="fn egui::lerp">lerp</a></div><div class="desc docblock-short">Linear interpolation.</div></li><li><div class="item-name"><a class="fn" href="fn.pos2.html" title="fn egui::pos2">pos2</a></div><div class="desc docblock-short"><code>pos2(x, y) == Pos2::new(x, y)</code></div></li><li><div class="item-name"><a class="fn" href="fn.remap.html" title="fn egui::remap">remap</a></div><div class="desc docblock-short">Linearly remap a value from one range to another,
so that when <code>x == from.start()</code> returns <code>to.start()</code>
and when <code>x == from.end()</code> returns <code>to.end()</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.remap_clamp.html" title="fn egui::remap_clamp">remap_clamp</a></div><div class="desc docblock-short">Like <a href="fn.remap.html" title="fn egui::remap"><code>remap</code></a>, but also clamps the value so that the returned value is always in the <code>to</code> range.</div></li><li><div class="item-name"><a class="fn" href="fn.vec2.html" title="fn egui::vec2">vec2</a></div><div class="desc docblock-short"><code>vec2(x, y) == Vec2::new(x, y)</code></div></li><li><div class="item-name"><a class="fn" href="fn.warn_if_debug_build.html" title="fn egui::warn_if_debug_build">warn_if_debug_build</a></div><div class="desc docblock-short">Helper function that adds a label when compiling with debug assertions enabled.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Aliases</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.IdMap.html" title="type egui::IdMap">IdMap</a></div><div class="desc docblock-short"><code>IdMap&lt;V&gt;</code> is a <code>HashMap&lt;Id, V&gt;</code> optimized by knowing that <a href="struct.Id.html" title="struct egui::Id"><code>Id</code></a> has good entropy, and doesnâ€™t need more hashing.</div></li></ul></section></div></main></body></html>