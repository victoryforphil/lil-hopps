<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="zvariant"><title>zvariant - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zvariant" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../zvariant/index.html"><img src="https://storage.googleapis.com/fdo-gitlab-uploads/project/avatar/3213/zbus-logomark.png" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../zvariant/index.html"><img src="https://storage.googleapis.com/fdo-gitlab-uploads/project/avatar/3213/zbus-logomark.png" alt="logo"></a><h2 class="location"><a href="#">Crate zvariant</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 3.15.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">zvariant</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/zvariant/lib.rs.html#1-1925">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="zvariant"><a href="#zvariant">zvariant</a></h2>
<p><a href="https://docs.rs/zvariant/"><img src="https://docs.rs/zvariant/badge.svg" alt="" /></a> <a href="https://crates.io/crates/zvariant"><img src="https://img.shields.io/crates/v/zvariant" alt="" /></a></p>
<p>This crate provides API for encoding/decoding of data to/from <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-marshaling">D-Bus wire format</a>. This binary
wire format is simple and very efficient and hence useful outside of D-Bus context as well. A
modified form of this format, <a href="https://developer.gnome.org/documentation/specifications/gvariant-specification-1.0.html">GVariant</a> is very commonly used for efficient storage of arbitrary
data and is also supported by this crate.</p>
<p>Since version 2.0, the API is <a href="https://crates.io/crates/serde">serde</a>-based and hence you’ll find it very intuitive if you’re
already familiar with serde. If you’re not familiar with serde, you may want to first read its
<a href="https://serde.rs/">tutorial</a> before learning further about this crate.</p>
<p><strong>Status:</strong> Stable.</p>
<h3 id="example-code"><a href="#example-code">Example code</a></h3>
<p>Serialization and deserialization is achieved through the <a href="https://docs.rs/zvariant/latest/zvariant/#functions">toplevel functions</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::HashMap;
<span class="kw">use </span>zvariant::{EncodingContext <span class="kw">as </span>Context, from_slice, to_bytes, Type};
<span class="kw">use </span>serde::{Deserialize, Serialize};
<span class="kw">use </span>byteorder::LE;

<span class="comment">// All serialization and deserialization API, needs a context.
</span><span class="kw">let </span>ctxt = Context::&lt;LE&gt;::new_dbus(<span class="number">0</span>);
<span class="comment">// You can also use the more efficient GVariant format:
// let ctxt = Context::&lt;LE&gt;::new_gvariant(0);

// i16
</span><span class="kw">let </span>encoded = to_bytes(ctxt, <span class="kw-2">&amp;</span><span class="number">42i16</span>).unwrap();
<span class="kw">let </span>decoded: i16 = from_slice(<span class="kw-2">&amp;</span>encoded, ctxt).unwrap();
<span class="macro">assert_eq!</span>(decoded, <span class="number">42</span>);

<span class="comment">// strings
</span><span class="kw">let </span>encoded = to_bytes(ctxt, <span class="kw-2">&amp;</span><span class="string">&quot;hello&quot;</span>).unwrap();
<span class="kw">let </span>decoded: <span class="kw-2">&amp;</span>str = from_slice(<span class="kw-2">&amp;</span>encoded, ctxt).unwrap();
<span class="macro">assert_eq!</span>(decoded, <span class="string">&quot;hello&quot;</span>);

<span class="comment">// tuples
</span><span class="kw">let </span>t = (<span class="string">&quot;hello&quot;</span>, <span class="number">42i32</span>, <span class="bool-val">true</span>);
<span class="kw">let </span>encoded = to_bytes(ctxt, <span class="kw-2">&amp;</span>t).unwrap();
<span class="kw">let </span>decoded: (<span class="kw-2">&amp;</span>str, i32, bool) = from_slice(<span class="kw-2">&amp;</span>encoded, ctxt).unwrap();
<span class="macro">assert_eq!</span>(decoded, t);

<span class="comment">// Vec
</span><span class="kw">let </span>v = <span class="macro">vec!</span>[<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world!&quot;</span>];
<span class="kw">let </span>encoded = to_bytes(ctxt, <span class="kw-2">&amp;</span>v).unwrap();
<span class="kw">let </span>decoded: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = from_slice(<span class="kw-2">&amp;</span>encoded, ctxt).unwrap();
<span class="macro">assert_eq!</span>(decoded, v);

<span class="comment">// Dictionary
</span><span class="kw">let </span><span class="kw-2">mut </span>map: HashMap&lt;i64, <span class="kw-2">&amp;</span>str&gt; = HashMap::new();
map.insert(<span class="number">1</span>, <span class="string">&quot;123&quot;</span>);
map.insert(<span class="number">2</span>, <span class="string">&quot;456&quot;</span>);
<span class="kw">let </span>encoded = to_bytes(ctxt, <span class="kw-2">&amp;</span>map).unwrap();
<span class="kw">let </span>decoded: HashMap&lt;i64, <span class="kw-2">&amp;</span>str&gt; = from_slice(<span class="kw-2">&amp;</span>encoded, ctxt).unwrap();
<span class="macro">assert_eq!</span>(decoded[<span class="kw-2">&amp;</span><span class="number">1</span>], <span class="string">&quot;123&quot;</span>);
<span class="macro">assert_eq!</span>(decoded[<span class="kw-2">&amp;</span><span class="number">2</span>], <span class="string">&quot;456&quot;</span>);

<span class="comment">// derive macros to handle custom types.
</span><span class="attr">#[derive(Deserialize, Serialize, Type, PartialEq, Debug)]
</span><span class="kw">struct </span>Struct&lt;<span class="lifetime">&#39;s</span>&gt; {
    field1: u16,
    field2: i64,
    field3: <span class="kw-2">&amp;</span><span class="lifetime">&#39;s </span>str,
}

<span class="macro">assert_eq!</span>(Struct::signature(), <span class="string">&quot;(qxs)&quot;</span>);
<span class="kw">let </span>s = Struct {
    field1: <span class="number">42</span>,
    field2: i64::max_value(),
    field3: <span class="string">&quot;hello&quot;</span>,
};
<span class="kw">let </span>ctxt = Context::&lt;LE&gt;::new_dbus(<span class="number">0</span>);
<span class="kw">let </span>encoded = to_bytes(ctxt, <span class="kw-2">&amp;</span>s).unwrap();
<span class="kw">let </span>decoded: Struct = from_slice(<span class="kw-2">&amp;</span>encoded, ctxt).unwrap();
<span class="macro">assert_eq!</span>(decoded, s);

<span class="comment">// It can handle enums too, just that all variants must have the same number and types of fields.
// Names of fields don&#39;t matter though. You can make use of `Value` or `OwnedValue` if you want to
// encode different data in different fields.
</span><span class="attr">#[derive(Deserialize, Serialize, Type, PartialEq, Debug)]
</span><span class="kw">enum </span>Enum&lt;<span class="lifetime">&#39;s</span>&gt; {
    Variant1 { field1: u16, field2: i64, field3: <span class="kw-2">&amp;</span><span class="lifetime">&#39;s </span>str },
    Variant2(u16, i64, <span class="kw-2">&amp;</span><span class="lifetime">&#39;s </span>str),
    Variant3 { f1: u16, f2: i64, f3: <span class="kw-2">&amp;</span><span class="lifetime">&#39;s </span>str },
}

<span class="comment">// Enum encoding uses a `u32` to denote the variant index. For unit-type enums that&#39;s all that&#39;s
// needed so the signature is just `u` but complex enums are encoded as a structure whose first
// field is the variant index and the second one is the field(s).
</span><span class="macro">assert_eq!</span>(Enum::signature(), <span class="string">&quot;(u(qxs))&quot;</span>);
<span class="kw">let </span>e = Enum::Variant3 {
    f1: <span class="number">42</span>,
    f2: i64::max_value(),
    f3: <span class="string">&quot;hello&quot;</span>,
};
<span class="kw">let </span>encoded = to_bytes(ctxt, <span class="kw-2">&amp;</span>e).unwrap();
<span class="kw">let </span>decoded: Enum = from_slice(<span class="kw-2">&amp;</span>encoded, ctxt).unwrap();
<span class="macro">assert_eq!</span>(decoded, e);

<span class="attr">#[derive(Deserialize, Serialize, Type, PartialEq, Debug)]
</span><span class="comment">// W/o `repr` spec, `u32` is assumed.
</span><span class="attr">#[repr(u8)]
</span><span class="kw">enum </span>UnitEnum {
    Variant1,
    Variant2,
    Variant3,
}

<span class="macro">assert_eq!</span>(UnitEnum::signature(), <span class="string">&quot;y&quot;</span>);
<span class="kw">let </span>encoded = to_bytes(ctxt, <span class="kw-2">&amp;</span>UnitEnum::Variant2).unwrap();
<span class="kw">let </span>e: UnitEnum = from_slice(<span class="kw-2">&amp;</span>encoded, ctxt).unwrap();
<span class="macro">assert_eq!</span>(e, UnitEnum::Variant2);

<span class="comment">// Unit enums can also be (de)serialized as strings.
</span><span class="attr">#[derive(Deserialize, Serialize, Type, PartialEq, Debug)]
#[zvariant(signature = <span class="string">&quot;s&quot;</span>)]
</span><span class="kw">enum </span>StrEnum {
    Variant1,
    Variant2,
    Variant3,
}

<span class="macro">assert_eq!</span>(StrEnum::signature(), <span class="string">&quot;s&quot;</span>);</code></pre></div>
<p>Apart from the obvious requirement of <a href="https://docs.rs/zvariant/latest/zvariant/struct.EncodingContext.html"><code>EncodingContext</code></a> instance by the main serialization and
deserialization API, the type being serialized or deserialized must also implement <code>Type</code>
trait in addition to <a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>Serialize</code></a> or <a href="https://docs.serde.rs/serde/de/trait.Deserialize.html"><code>Deserialize</code></a>, respectively. Please refer to <a href="https://docs.rs/zvariant/latest/zvariant/trait.Type.html"><code>Type</code>
module documentation</a> for more details.</p>
<p>Most of the <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#basic-types">basic types</a> of D-Bus match 1-1 with all the primitive Rust types. The only two
exceptions being, <a href="https://docs.rs/zvariant/latest/zvariant/struct.Signature.html"><code>Signature</code></a> and <a href="https://docs.rs/zvariant/latest/zvariant/struct.ObjectPath.html"><code>ObjectPath</code></a>, which are really just strings. These types
are covered by the <a href="https://docs.rs/zvariant/latest/zvariant/trait.Basic.html"><code>Basic</code></a> trait.</p>
<p>Similarly, most of the <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#container-types">container types</a> also map nicely to the usual Rust types and
collections (as can be seen in the example code above). The only note worthy exception being
ARRAY type. As arrays in Rust are fixed-sized, serde treats them as tuples and so does this
crate. This means they are encoded as STRUCT type of D-Bus. If you need to serialize to, or
deserialize from a D-Bus array, you’ll need to use a <a href="https://doc.rust-lang.org/std/primitive.slice.html">slice</a> (array can easily be converted to a
slice), a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> or an <a href="https://docs.rs/arrayvec/0.7.1/arrayvec/struct.ArrayVec.html"><code>arrayvec::ArrayVec</code></a>.</p>
<p>D-Bus string types, including <a href="https://docs.rs/zvariant/latest/zvariant/struct.Signature.html"><code>Signature</code></a> and <a href="https://docs.rs/zvariant/latest/zvariant/struct.ObjectPath.html"><code>ObjectPath</code></a>, require one additional
restriction that strings in Rust do not. They must not contain any interior null bytes (<code>'\0'</code>).
Encoding/Decoding strings that contain this character will return an error.</p>
<p>The generic D-Bus type, <code>VARIANT</code> is represented by <code>Value</code>, an enum that holds exactly one
value of any of the other types. Please refer to <a href="https://docs.rs/zvariant/latest/zvariant/enum.Value.html"><code>Value</code> module documentation</a> for examples.</p>
<h3 id="no-std"><a href="#no-std">no-std</a></h3>
<p>While <code>std</code> is currently a hard requirement, optional <code>no-std</code> support is planned in the future.
On the other hand, <code>noalloc</code> support is not planned as it will be extremely difficult to
accomplish. However, community contribution can change that. 😊</p>
<h3 id="optional-features"><a href="#optional-features">Optional features</a></h3><div><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td>arrayvec</td><td>Implement <code>Type</code> for <a href="https://docs.rs/arrayvec/0.7.1/arrayvec/struct.ArrayVec.html"><code>arrayvec::ArrayVec</code></a> and <a href="https://docs.rs/arrayvec/0.7.1/arrayvec/struct.ArrayString.html"><code>arrayvec::ArrayString</code></a></td></tr>
<tr><td>enumflags2</td><td>Implement <code>Type</code> for <a href="https://docs.rs/enumflags2/latest/enumflags2/struct.BitFlags.html"><code>enumflags2::BitFlags</code></a><code>&lt;F&gt;</code></td></tr>
</tbody></table>
</div></div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="dbus/index.html" title="mod zvariant::dbus">dbus</a></div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Array.html" title="struct zvariant::Array">Array</a></div><div class="desc docblock-short">A helper type to wrap arrays in a <a href="enum.Value.html#variant.Array"><code>Value</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ArraySeed.html" title="struct zvariant::ArraySeed">ArraySeed</a></div><div class="desc docblock-short">Use this to deserialize an <a href="struct.Array.html" title="struct zvariant::Array">Array</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.DeserializeValue.html" title="struct zvariant::DeserializeValue">DeserializeValue</a></div><div class="desc docblock-short">A wrapper to deserialize a value to <code>T: Type + Deserialize</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Dict.html" title="struct zvariant::Dict">Dict</a></div><div class="desc docblock-short">A helper type to wrap dictionaries in a <a href="enum.Value.html#variant.Dict"><code>Value</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.EncodingContext.html" title="struct zvariant::EncodingContext">EncodingContext</a></div><div class="desc docblock-short">The encoding context to use with the <a href="index.html#functions">serialization and deserialization</a> API.</div></li><li><div class="item-name"><a class="struct" href="struct.Fd.html" title="struct zvariant::Fd">Fd</a></div><div class="desc docblock-short">A <a href="https://doc.rust-lang.org/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a> wrapper.</div></li><li><div class="item-name"><a class="struct" href="struct.ObjectPath.html" title="struct zvariant::ObjectPath">ObjectPath</a></div><div class="desc docblock-short">String that identifies objects at a given destination on the D-Bus bus.</div></li><li><div class="item-name"><a class="struct" href="struct.Optional.html" title="struct zvariant::Optional">Optional</a></div><div class="desc docblock-short">An optional value.</div></li><li><div class="item-name"><a class="struct" href="struct.OwnedFd.html" title="struct zvariant::OwnedFd">OwnedFd</a></div><div class="desc docblock-short">An owned <a href="https://doc.rust-lang.org/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a> wrapper.</div></li><li><div class="item-name"><a class="struct" href="struct.OwnedObjectPath.html" title="struct zvariant::OwnedObjectPath">OwnedObjectPath</a></div><div class="desc docblock-short">Owned <a href="struct.ObjectPath.html"><code>ObjectPath</code></a></div></li><li><div class="item-name"><a class="struct" href="struct.OwnedSignature.html" title="struct zvariant::OwnedSignature">OwnedSignature</a></div><div class="desc docblock-short">Owned <a href="struct.Signature.html"><code>Signature</code></a></div></li><li><div class="item-name"><a class="struct" href="struct.OwnedValue.html" title="struct zvariant::OwnedValue">OwnedValue</a></div><div class="desc docblock-short">Owned <a href="enum.Value.html"><code>Value</code></a></div></li><li><div class="item-name"><a class="struct" href="struct.SerializeValue.html" title="struct zvariant::SerializeValue">SerializeValue</a></div><div class="desc docblock-short">A wrapper to serialize <code>T: Type + Serialize</code> as a value.</div></li><li><div class="item-name"><a class="struct" href="struct.Signature.html" title="struct zvariant::Signature">Signature</a></div><div class="desc docblock-short">String that <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#type-system">identifies</a> the type of an encoded value.</div></li><li><div class="item-name"><a class="struct" href="struct.Str.html" title="struct zvariant::Str">Str</a></div><div class="desc docblock-short">A string wrapper.</div></li><li><div class="item-name"><a class="struct" href="struct.Structure.html" title="struct zvariant::Structure">Structure</a></div><div class="desc docblock-short">A helper type to wrap structs in <a href="enum.Value.html"><code>Value</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.StructureBuilder.html" title="struct zvariant::StructureBuilder">StructureBuilder</a></div><div class="desc docblock-short">Use this to efficiently build a <a href="struct.Structure.html"><code>Structure</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.StructureSeed.html" title="struct zvariant::StructureSeed">StructureSeed</a></div><div class="desc docblock-short">Use this to deserialize a <a href="struct.Structure.html"><code>Structure</code></a>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Deserializer.html" title="enum zvariant::Deserializer">Deserializer</a></div><div class="desc docblock-short">Our deserialization implementation.</div></li><li><div class="item-name"><a class="enum" href="enum.EncodingFormat.html" title="enum zvariant::EncodingFormat">EncodingFormat</a></div><div class="desc docblock-short">The encoding format.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum zvariant::Error">Error</a></div><div class="desc docblock-short">Error type used by zvariant API.</div></li><li><div class="item-name"><a class="enum" href="enum.MaxDepthExceeded.html" title="enum zvariant::MaxDepthExceeded">MaxDepthExceeded</a></div><div class="desc docblock-short">Enum representing the max depth exceeded error.</div></li><li><div class="item-name"><a class="enum" href="enum.Serializer.html" title="enum zvariant::Serializer">Serializer</a></div><div class="desc docblock-short">Our serialization implementation.</div></li><li><div class="item-name"><a class="enum" href="enum.Value.html" title="enum zvariant::Value">Value</a></div><div class="desc docblock-short">A generic container, in the form of an enum that holds exactly one value of any of the other
types.</div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.ARRAY_SIGNATURE_CHAR.html" title="constant zvariant::ARRAY_SIGNATURE_CHAR">ARRAY_SIGNATURE_CHAR</a></div><div class="desc docblock-short">The prefix of ARRAY type signature, as a character. Provided for manual signature creation.</div></li><li><div class="item-name"><a class="constant" href="constant.ARRAY_SIGNATURE_STR.html" title="constant zvariant::ARRAY_SIGNATURE_STR">ARRAY_SIGNATURE_STR</a></div><div class="desc docblock-short">The prefix of ARRAY type signature, as a string. Provided for manual signature creation.</div></li><li><div class="item-name"><a class="constant" href="constant.DICT_ENTRY_SIG_END_CHAR.html" title="constant zvariant::DICT_ENTRY_SIG_END_CHAR">DICT_ENTRY_SIG_END_CHAR</a></div><div class="desc docblock-short">The closing character of DICT_ENTRY type signature. Provided for manual signature creation.</div></li><li><div class="item-name"><a class="constant" href="constant.DICT_ENTRY_SIG_END_STR.html" title="constant zvariant::DICT_ENTRY_SIG_END_STR">DICT_ENTRY_SIG_END_STR</a></div><div class="desc docblock-short">The closing character of DICT_ENTRY type signature, as a string. Provided for manual signature
creation.</div></li><li><div class="item-name"><a class="constant" href="constant.DICT_ENTRY_SIG_START_CHAR.html" title="constant zvariant::DICT_ENTRY_SIG_START_CHAR">DICT_ENTRY_SIG_START_CHAR</a></div><div class="desc docblock-short">The opening character of DICT_ENTRY type signature. Provided for manual signature creation.</div></li><li><div class="item-name"><a class="constant" href="constant.DICT_ENTRY_SIG_START_STR.html" title="constant zvariant::DICT_ENTRY_SIG_START_STR">DICT_ENTRY_SIG_START_STR</a></div><div class="desc docblock-short">The opening character of DICT_ENTRY type signature, as a string. Provided for manual signature
creation.</div></li><li><div class="item-name"><a class="constant" href="constant.STRUCT_SIG_END_CHAR.html" title="constant zvariant::STRUCT_SIG_END_CHAR">STRUCT_SIG_END_CHAR</a></div><div class="desc docblock-short">The closing character of STRUCT type signature. Provided for manual signature creation.</div></li><li><div class="item-name"><a class="constant" href="constant.STRUCT_SIG_END_STR.html" title="constant zvariant::STRUCT_SIG_END_STR">STRUCT_SIG_END_STR</a></div><div class="desc docblock-short">The closing character of STRUCT type signature, as a string. Provided for manual signature
creation.</div></li><li><div class="item-name"><a class="constant" href="constant.STRUCT_SIG_START_CHAR.html" title="constant zvariant::STRUCT_SIG_START_CHAR">STRUCT_SIG_START_CHAR</a></div><div class="desc docblock-short">The opening character of STRUCT type signature. Provided for manual signature creation.</div></li><li><div class="item-name"><a class="constant" href="constant.STRUCT_SIG_START_STR.html" title="constant zvariant::STRUCT_SIG_START_STR">STRUCT_SIG_START_STR</a></div><div class="desc docblock-short">The opening character of STRUCT type signature, as a string. Provided for manual signature
creation.</div></li><li><div class="item-name"><a class="constant" href="constant.VARIANT_SIGNATURE_CHAR.html" title="constant zvariant::VARIANT_SIGNATURE_CHAR">VARIANT_SIGNATURE_CHAR</a></div><div class="desc docblock-short">The VARIANT type signature. Provided for manual signature creation.</div></li><li><div class="item-name"><a class="constant" href="constant.VARIANT_SIGNATURE_STR.html" title="constant zvariant::VARIANT_SIGNATURE_STR">VARIANT_SIGNATURE_STR</a></div><div class="desc docblock-short">The VARIANT type signature, as a string. Provided for manual signature creation.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Basic.html" title="trait zvariant::Basic">Basic</a></div><div class="desc docblock-short">Trait for basic types.</div></li><li><div class="item-name"><a class="trait" href="trait.DynamicDeserialize.html" title="trait zvariant::DynamicDeserialize">DynamicDeserialize</a></div><div class="desc docblock-short">Types that deserialize based on dynamic signatures.</div></li><li><div class="item-name"><a class="trait" href="trait.DynamicType.html" title="trait zvariant::DynamicType">DynamicType</a></div><div class="desc docblock-short">Types with dynamic signatures.</div></li><li><div class="item-name"><a class="trait" href="trait.NoneValue.html" title="trait zvariant::NoneValue">NoneValue</a></div><div class="desc docblock-short">Type that uses a special value to be used as none.</div></li><li><div class="item-name"><a class="trait" href="trait.Type.html" title="trait zvariant::Type">Type</a></div><div class="desc docblock-short">Trait implemented by all serializable types.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.from_slice.html" title="fn zvariant::from_slice">from_slice</a></div><div class="desc docblock-short">Deserialize <code>T</code> from a given slice of bytes.</div></li><li><div class="item-name"><a class="fn" href="fn.from_slice_fds.html" title="fn zvariant::from_slice_fds">from_slice_fds</a></div><div class="desc docblock-short">Deserialize <code>T</code> from a given slice of bytes, containing file descriptor indices.</div></li><li><div class="item-name"><a class="fn" href="fn.from_slice_fds_for_dynamic_signature.html" title="fn zvariant::from_slice_fds_for_dynamic_signature">from_slice_fds_for_dynamic_signature</a></div><div class="desc docblock-short">Deserialize <code>T</code> from a given slice of bytes containing file descriptor indices, with the given
signature.</div></li><li><div class="item-name"><a class="fn" href="fn.from_slice_fds_for_signature.html" title="fn zvariant::from_slice_fds_for_signature">from_slice_fds_for_signature</a></div><div class="desc docblock-short">Deserialize <code>T</code> from a given slice of bytes containing file descriptor indices, with the given
signature.</div></li><li><div class="item-name"><a class="fn" href="fn.from_slice_fds_with_seed.html" title="fn zvariant::from_slice_fds_with_seed">from_slice_fds_with_seed</a></div><div class="desc docblock-short">Deserialize <code>T</code> from a given slice of bytes containing file descriptor indices, using the given
seed.</div></li><li><div class="item-name"><a class="fn" href="fn.from_slice_for_dynamic_signature.html" title="fn zvariant::from_slice_for_dynamic_signature">from_slice_for_dynamic_signature</a></div><div class="desc docblock-short">Deserialize <code>T</code> from a given slice of bytes containing file descriptor indices, with the given
signature.</div></li><li><div class="item-name"><a class="fn" href="fn.from_slice_for_signature.html" title="fn zvariant::from_slice_for_signature">from_slice_for_signature</a></div><div class="desc docblock-short">Deserialize <code>T</code> from a given slice of bytes with the given signature.</div></li><li><div class="item-name"><a class="fn" href="fn.from_slice_with_seed.html" title="fn zvariant::from_slice_with_seed">from_slice_with_seed</a></div><div class="desc docblock-short">Deserialize <code>T</code> from a given slice of bytes containing file descriptor indices, using the given
seed.</div></li><li><div class="item-name"><a class="fn" href="fn.serialized_size.html" title="fn zvariant::serialized_size">serialized_size</a></div><div class="desc docblock-short">Calculate the serialized size of <code>T</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.serialized_size_fds.html" title="fn zvariant::serialized_size_fds">serialized_size_fds</a></div><div class="desc docblock-short">Calculate the serialized size of <code>T</code> that (potentially) contains FDs.</div></li><li><div class="item-name"><a class="fn" href="fn.to_bytes.html" title="fn zvariant::to_bytes">to_bytes</a></div><div class="desc docblock-short">Serialize <code>T</code> as a byte vector.</div></li><li><div class="item-name"><a class="fn" href="fn.to_bytes_fds.html" title="fn zvariant::to_bytes_fds">to_bytes_fds</a></div><div class="desc docblock-short">Serialize <code>T</code> that (potentially) contains FDs, as a byte vector.</div></li><li><div class="item-name"><a class="fn" href="fn.to_bytes_fds_for_signature.html" title="fn zvariant::to_bytes_fds_for_signature">to_bytes_fds_for_signature</a></div><div class="desc docblock-short">Serialize <code>T</code> that (potentially) contains FDs and has the given signature, to a new byte vector.</div></li><li><div class="item-name"><a class="fn" href="fn.to_bytes_for_signature.html" title="fn zvariant::to_bytes_for_signature">to_bytes_for_signature</a></div><div class="desc docblock-short">Serialize <code>T</code> that has the given signature, to a new byte vector.</div></li><li><div class="item-name"><a class="fn" href="fn.to_writer.html" title="fn zvariant::to_writer">to_writer</a></div><div class="desc docblock-short">Serialize <code>T</code> to the given <code>writer</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.to_writer_fds.html" title="fn zvariant::to_writer_fds">to_writer_fds</a></div><div class="desc docblock-short">Serialize <code>T</code> that (potentially) contains FDs, to the given <code>writer</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.to_writer_fds_for_signature.html" title="fn zvariant::to_writer_fds_for_signature">to_writer_fds_for_signature</a></div><div class="desc docblock-short">Serialize <code>T</code> that (potentially) contains FDs and has the given signature, to the given
<code>writer</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.to_writer_for_signature.html" title="fn zvariant::to_writer_for_signature">to_writer_for_signature</a></div><div class="desc docblock-short">Serialize <code>T</code> that has the given signature, to the given <code>writer</code>.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Result.html" title="type zvariant::Result">Result</a></div><div class="desc docblock-short">Alias for a <code>Result</code> with the error type <code>zvariant::Error</code>.</div></li></ul><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.DeserializeDict.html" title="derive zvariant::DeserializeDict">DeserializeDict</a></div><div class="desc docblock-short">Adds <a href="https://docs.serde.rs/serde/de/trait.Deserialize.html"><code>Deserialize</code></a> implementation to structs to be deserialized from <code>a{sv}</code> type.</div></li><li><div class="item-name"><a class="derive" href="derive.OwnedValue.html" title="derive zvariant::OwnedValue">OwnedValue</a></div><div class="desc docblock-short">Implements conversions for your type to/from <a href="https://docs.rs/zvariant/2.10.0/zvariant/struct.OwnedValue.html"><code>OwnedValue</code></a>.</div></li><li><div class="item-name"><a class="derive" href="derive.SerializeDict.html" title="derive zvariant::SerializeDict">SerializeDict</a></div><div class="desc docblock-short">Adds <a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>Serialize</code></a> implementation to structs to be serialized as <code>a{sv}</code> type.</div></li><li><div class="item-name"><a class="derive" href="derive.Type.html" title="derive zvariant::Type">Type</a></div><div class="desc docblock-short">Derive macro to add <a href="https://docs.rs/zvariant/2.10.0/zvariant/trait.Type.html"><code>Type</code></a> implementation to structs and enums.</div></li><li><div class="item-name"><a class="derive" href="derive.TypeDict.html" title="derive zvariant::TypeDict">TypeDict</a></div><div class="desc docblock-short">Derive macro to add <a href="../zvariant/trait.Type.html"><code>Type</code></a> implementation to structs serialized as <code>a{sv}</code> type.</div></li><li><div class="item-name"><a class="derive" href="derive.Value.html" title="derive zvariant::Value">Value</a></div><div class="desc docblock-short">Implements conversions for your type to/from <a href="https://docs.rs/zvariant/2.10.0/zvariant/enum.Value.html"><code>Value</code></a>.</div></li></ul></section></div></main></body></html>