<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Duplicates the item and substitutes specific identifiers for different code snippets in each duplicate."><title>duplicate_item in duplicate - Rust</title><script> if (window.location.protocol !== "file:") document.write(`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2">`)</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="duplicate" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0 (9b00956e5 2024-04-29)" data-channel="1.78.0" data-search-js="search-42d8da7a6b9792c2.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-12cf3b4f4f9dc36d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../duplicate/index.html">duplicate</a><span class="version">1.0.0</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../duplicate/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Attribute Macro <a href="index.html">duplicate</a>::<wbr><a class="attr" href="#">duplicate_item</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/duplicate/lib.rs.html#1010">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[duplicate_item]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Duplicates the item and substitutes specific identifiers for different code
snippets in each duplicate.</p>
<h2 id="short-syntax"><a class="doc-anchor" href="#short-syntax">§</a>Short Syntax</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>duplicate::duplicate_item;
<span class="kw">trait </span>IsMax {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool;
}

<span class="attr">#[duplicate_item(
  int_type  max_value;
  [ u8 ]    </span>[ <span class="number">255 </span>];
  [ u16 ]   [ <span class="number">65_535 </span>];
  [ u32 ]   [ <span class="number">4_294_967_295 </span>];
)]
<span class="kw">impl </span>IsMax <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>== max_value
  }
}

<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_max());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_max());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_max());</code></pre></div>
<p>The implementation of <code>IsMax</code> is duplicated 3 times:</p>
<ol>
<li>For the type <code>u8</code> and the its maximum value <code>255</code>.</li>
<li>For the type <code>u16</code> and the its maximum value <code>65_535 </code>.</li>
<li>For the type <code>u32</code> and the its maximum value <code>4_294_967_295 </code>.</li>
</ol>
<p>This syntax must start with a list of all identifiers followed by <code>;</code>.
Then a <code>;</code> seperated list of substitution groups must be given (at least 1
group). Every group is a list of substitutions, one for each substitution
identifier given in the first line.
The substitutions must be enclosed in <code>[]</code> but are otherwise
free.</p>
<h2 id="verbose-syntax"><a class="doc-anchor" href="#verbose-syntax">§</a>Verbose Syntax</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>duplicate::duplicate_item;
<span class="kw">trait </span>IsMax {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool;
}

<span class="attr">#[duplicate_item(
  [
    int_type  [ u8 ]
    </span>max_value [ <span class="number">255 </span>]
  ]
  [
    int_type  [ u16 ]
    max_value [ <span class="number">65_535 </span>]
  ]
  [
    max_value [ <span class="number">4_294_967_295 </span>]
    int_type  [ u32 ]
  ]
)]
<span class="kw">impl </span>IsMax <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>== max_value
  }
}

<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_max());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_max());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_max());</code></pre></div>
<p>Has the same functionality as the previous short-syntax example.</p>
<p>For each duplicate needed, a <em>substitution group</em> must be given enclosed in
<code>[]</code>. A substitution group is a set of identifiers and
substitution pairs, like in the short syntax, but there can only be one
substitution per identifier. All substitution groups must have the same
identifiers, however their order is unimportant, as can be seen from the
last substitution group above, where <code>max_value</code> comes before <code>int_type</code>.</p>
<h2 id="parameterized-substitutoin"><a class="doc-anchor" href="#parameterized-substitutoin">§</a>Parameterized Substitutoin</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>duplicate::duplicate_item;
<span class="kw">struct </span>VecWrap&lt;T&gt;(Vec&lt;T&gt;);

<span class="kw">impl</span>&lt;T&gt; VecWrap&lt;T&gt; {
  <span class="attr">#[duplicate_item(
    method     reference(lifetime, <span class="kw">type</span>);
    [get]      </span>[&amp; <span class="lifetime">'lifetime </span><span class="kw">type</span>];
    [get_mut]  [&amp; <span class="lifetime">'lifetime </span><span class="kw-2">mut </span><span class="kw">type</span>];
  )]
  <span class="kw">pub fn </span>method&lt;<span class="lifetime">'a</span>&gt;(<span class="self">self</span>: reference([a],[<span class="self">Self</span>]),idx: usize) -&gt; <span class="prelude-ty">Option</span>&lt;reference([a],[T])&gt; {
    <span class="self">self</span>.<span class="number">0</span>.method(idx)
  }
}

<span class="kw">let </span><span class="kw-2">mut </span>vec = VecWrap(<span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>vec.get(<span class="number">0</span>).unwrap(), <span class="number">1</span>);
<span class="kw-2">*</span>vec.get_mut(<span class="number">1</span>).unwrap() = <span class="number">5</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>vec.get(<span class="number">1</span>).unwrap(), <span class="number">5</span>);</code></pre></div>
<p>This implements two versions of the method:</p>
<ul>
<li><code>get</code>: Borrows <code>self</code> immutably and return a shared reference.</li>
<li><code>get_mut</code>: Borrows <code>self</code> mutably and returns a mutable reference.</li>
</ul>
<p>If an identifier is followed by parenthises (in both its declaration and its
use), a set of parameters can be provided to customize the subtituion for
each use. In the declaration a list of identifiers is given, which can be
used in its substitutions. When using the identifier, argument code snippets
must be given in a comma separated list, with each argument being inclosed
in <code>[]</code>.</p>
<p>Parameterized substitution is also available for the verbose syntax:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;T&gt; VecWrap&lt;T&gt; {
  <span class="attr">#[duplicate_item(
    [
      method                     [get]
      </span>reference(lifetime, <span class="kw">type</span>)  [&amp; <span class="lifetime">'lifetime </span><span class="kw">type</span>]
    ]
    [
      method                     [get_mut]
      reference(lifetime, <span class="kw">type</span>)  [&amp; <span class="lifetime">'lifetime </span><span class="kw-2">mut </span><span class="kw">type</span>]
    ]
  )]
  <span class="kw">pub fn </span>method&lt;<span class="lifetime">'a</span>&gt;(<span class="self">self</span>: reference([a],[<span class="self">Self</span>]),idx: usize) -&gt; <span class="prelude-ty">Option</span>&lt;reference([a],[T])&gt; {
    <span class="self">self</span>.<span class="number">0</span>.method(idx)
  }
}</code></pre></div>
<h2 id="nested-invocation"><a class="doc-anchor" href="#nested-invocation">§</a>Nested Invocation</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>duplicate::duplicate_item;
<span class="kw">trait </span>IsNegative {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool;
}

<span class="attr">#[duplicate_item(
  int_type implementation;
  <span class="macro">duplicate!</span>{
    [                                  <span class="comment">// -+
      </span>int_type_nested;[u8]</span>;[u16];[u32] <span class="comment">//  | Nested invocation producing 3
    </span>]                                  <span class="comment">//  | substitution groups
    </span>[ int_type_nested ] [ <span class="bool-val">false </span>];     <span class="comment">//  |
  </span>}                                    <span class="comment">// -+
  </span>[ i8 ] [ <span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0 </span>]                 <span class="comment">// -- Substitution group 4
</span>)]
<span class="kw">impl </span>IsNegative <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    implementation
  }
}

<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i8</span>.is_negative());</code></pre></div>
<p>This implements <code>IsNegative</code> 4 times:</p>
<ol>
<li>For the type <code>u8</code> with the implementation of the method simply returning
<code>false</code>. 1. For the type <code>u16</code> the same way as <code>u8</code>.</li>
<li>For the type <code>u32</code> the same way as <code>u8</code> and <code>u16</code>.</li>
<li>For <code>i8</code> with the implementation of the method checking whether it’s less
than <code>0</code>.</li>
</ol>
<p>We used <code>#</code> to start a <em>nested invocation</em> of the macro. In it, we use the
identifier <code>int_type_nested</code> to substitute the 3 unsigned integer types into
the body of the nested invocation, which is a substitution group for the
outer macro invocation. This therefore produces the three substitution
groups that makes the outer macro make the duplicates for the unsigned
integers.</p>
<p>This code is identical to the following, which doesn’t use nested
invocation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  int_type implementation;
  [ u8 ]  </span>[ <span class="bool-val">false </span>];
  [ u16 ] [ <span class="bool-val">false </span>];
  [ u32 ] [ <span class="bool-val">false </span>];
  [ i8 ]  [ <span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0 </span>]
)]
<span class="kw">impl </span>IsNegative <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    implementation
  }
}</code></pre></div>
<p>Nested invocation is also available for the verbose syntax:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>duplicate::duplicate_item;
<span class="kw">trait </span>IsNegative {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool;
}

<span class="attr">#[duplicate_item(
  <span class="macro">duplicate!</span>{                            <span class="comment">// -+
    </span>[ int_type_nested;[u8]</span>;[u16];[u32] ] <span class="comment">//  |
    </span>[                                    <span class="comment">//  | Nested invocation producing 3
      </span>int_type [ int_type_nested ]       <span class="comment">//  | substitution groups
      </span>implementation [ <span class="bool-val">false </span>]           <span class="comment">//  |
    </span>]                                    <span class="comment">//  |
  </span>}                                      <span class="comment">// -+
  </span>[                                      <span class="comment">// -+
    </span>int_type [ i8 ]                      <span class="comment">//  | Substitution group 4
    </span>implementation [ <span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0 </span>]         <span class="comment">//  |
  </span>]                                      <span class="comment">// -+
</span>)]
<span class="kw">impl </span>IsNegative <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    implementation
  }
}

<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i8</span>.is_negative());</code></pre></div>
<h3 id="global-substitution"><a class="doc-anchor" href="#global-substitution">§</a>Global Substitution</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  typ1 [<span class="prelude-val">Some</span>&lt;Complex&lt;()&gt;, Type&lt;WeDont&lt;Want, To, Repeat&gt;&gt;&gt;]</span>;
  typ2 [<span class="prelude-val">Some</span>&lt;Other, Complex&lt;Type&lt;(To, Repeat)&gt;&gt;&gt;];
  method     reference(<span class="kw">type</span>);
  [get]      [&amp; <span class="kw">type</span>];
  [get_mut]  [<span class="kw-2">&amp;mut </span><span class="kw">type</span>];
)]
<span class="kw">fn </span>method(
  arg0: reference([Type&lt;()&gt;]),
  arg1: typ1,
  arg2: typ2)
  -&gt; (reference([typ1]), reference([typ2]))
{
  ...
}</code></pre></div>
<p>The global substitutions (<code>typ1</code> and <code>typ2</code>) are substituted in both
duplicates of the function. Global substitutions have the same syntax as
verbose syntax substitutions, are <code>;</code> separated (even from following
substitutions groups), must all be defined at the beginning, and aren’t
usable in the invocation itself but only in the code being duplicated.</p>
</div></details></section></div></main></body></html>