<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides macros for easy code duplication with substitution:"><title>duplicate - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="duplicate" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0 (79e9716c9 2023-11-13)" data-channel="1.74.0" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../duplicate/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../duplicate/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate duplicate</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.0.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">duplicate</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/duplicate/lib.rs.html#1-1293">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides macros for easy code duplication with substitution:</p>
<ul>
<li><a href="attr.duplicate_item.html"><code>duplicate_item</code></a>: Attribute macro.</li>
<li><a href="macro.duplicate.html"><code>duplicate</code></a>: Function-like procedural macro.</li>
</ul>
<p>The only major difference between the two is where you can use them.
Therefore, the following section presents how to use
<a href="attr.duplicate_item.html"><code>duplicate_item</code></a> only. Refer to <a href="macro.duplicate.html"><code>duplicate</code></a>’s documentation for how it
defers from what is specified below.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>Say you have a trait with a method <code>is_max</code> that should return <code>true</code> if the
value of the object is the maximum allowed and <code>false</code> otherwise:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">trait </span>IsMax {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool;
}</code></pre></div>
<p>You would like to implement this trait for the three integer types <code>u8</code>,
<code>u16</code>, and <code>u32</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>IsMax <span class="kw">for </span>u8 {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>== <span class="number">255
  </span>}
}
<span class="kw">impl </span>IsMax <span class="kw">for </span>u16 {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>== <span class="number">65_535
  </span>}
}
<span class="kw">impl </span>IsMax <span class="kw">for </span>u32 {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>== <span class="number">4_294_967_295
  </span>}
}</code></pre></div>
<p>This is a lot of repetition. Only the type and the maximum value are
actually different between the three implementations. This might not be much
in our case, but imagine doing this for all the integer types (10, as of the
last count.) We can use the <code>duplicate_item</code> attribute to avoid repeating
ourselves:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>duplicate::duplicate_item;
<span class="attr">#[duplicate_item(
  int_type  max_value;
  [ u8 ]    </span>[ <span class="number">255 </span>];
  [ u16 ]   [ <span class="number">65_535 </span>];
  [ u32 ]   [ <span class="number">4_294_967_295 </span>];
)]
<span class="kw">impl </span>IsMax <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>== max_value
  }
}

<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_max());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_max());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_max());</code></pre></div>
<p>The above code will expand to the three implementations before it.
The attribute invocation specifies that the following item should be
substituted by three duplicates of itself. Additionally, each occurrence of
the identifier <code>int_type</code> in the first duplicate should be replaced by <code>u8</code>,
in the second duplicate by <code>u16</code>, and in the last by <code>u32</code>. Likewise, each
occurrence of <code>max_value</code> should be replaced by <code>255</code>, <code>65_535</code>, and
<code>4_294_967_295</code> in the first, second, and third duplicates respectively.</p>
<p><code>int_type</code> and <code>max_value</code> are called <em>substitution identifiers</em>, while <code>[ u8 ]</code>, <code>[ u16 ]</code>, and <code>[ u32 ]</code> are each <em>substitutions</em> for <code>int_type</code> and
<code>[255]</code>, <code>[65_535]</code>, and <code>[4_294_967_295]</code> are substitutions for
<code>max_value</code>. Each pair of substitutions for the identifiers is called a
<em>substitution group</em>. Substitution groups must be seperated by <code>;</code> and the
number of duplicates made is equal to the number of subsitution groups.</p>
<p>Substitution identifiers must be valid Rust identifiers.
The code inside substitutions can be arbitrary, as long as the expanded code
is valid.</p>
<h3 id="parameterized-substitution"><a href="#parameterized-substitution">Parameterized Substitution</a></h3>
<p>Say we have a struct that wraps a vector and we want to give
access to the vector’s <code>get</code> and <code>get_mut</code> methods directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>VecWrap&lt;T&gt;(Vec&lt;T&gt;);

<span class="kw">impl</span>&lt;T&gt; VecWrap&lt;T&gt; {
  <span class="kw">pub fn </span>get(<span class="kw-2">&amp;</span><span class="self">self</span>, idx: usize) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>T&gt; {
    <span class="self">self</span>.<span class="number">0</span>.get(idx)
  }
  <span class="kw">pub fn </span>get_mut(<span class="kw-2">&amp;mut </span><span class="self">self</span>, idx: usize) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;mut </span>T&gt; {
    <span class="self">self</span>.<span class="number">0</span>.get_mut(idx)
  }
}

<span class="kw">let </span><span class="kw-2">mut </span>vec = VecWrap(<span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>vec.get(<span class="number">0</span>).unwrap(), <span class="number">1</span>);
<span class="kw-2">*</span>vec.get_mut(<span class="number">1</span>).unwrap() = <span class="number">5</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>vec.get(<span class="number">1</span>).unwrap(), <span class="number">5</span>);</code></pre></div>
<p>Even though the implementations of the two versions of <code>get</code> are almost
identical, we will always need to duplicate the code, because Rust cannot be
generic over mutability. <em>Parameterized substitution</em> allows us to pass code
snippets to substitution identifiers to customize the substitution for that
specific use of the identifier. We can use it to help with the
implementation of constant and mutable versions of methods and functions.
The following <code>impl</code> is identical to the above code:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;T&gt; VecWrap&lt;T&gt; {
  <span class="attr">#[duplicate_item(
    method     reference(<span class="kw">type</span>);
    [get]      </span>[&amp; <span class="kw">type</span>];
    [get_mut]  [<span class="kw-2">&amp;mut </span><span class="kw">type</span>];
  )]
  <span class="kw">pub fn </span>method(<span class="self">self</span>: reference([<span class="self">Self</span>]), idx: usize) -&gt; <span class="prelude-ty">Option</span>&lt;reference([T])&gt; {
    <span class="self">self</span>.<span class="number">0</span>.method(idx)
  }
}</code></pre></div>
<p>In a <code>duplicate_item</code> invocation, if a substitution identifier is followed
by parenthises containing a list of parameters, they can be used in the
substitution. In this example, the <code>reference</code> identifier takes 1 parameter
named <code>type</code>, which is used in the substitutions to create either a shared
reference to the type or a mutable one. When using the <code>reference</code> in the
method declaration, we give it different types as arguments to construct
either shared or mutable references.
E.g. <code>reference([Self])</code> becomes <code>&amp;Self</code> in the first duplicate and <code>&amp;mut Self</code> in the second. An argument can be any code snippet inside <code>[]</code>.</p>
<p>A substitution identifier can take any number of parameters.
We can use this if we need to also provide the references with a lifetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;T&gt; VecWrap&lt;T&gt; {
  <span class="attr">#[duplicate_item(
    method     reference(lifetime, <span class="kw">type</span>);
    [get]      </span>[&amp; <span class="lifetime">&#39;lifetime </span><span class="kw">type</span>];
    [get_mut]  [&amp; <span class="lifetime">&#39;lifetime </span><span class="kw-2">mut </span><span class="kw">type</span>];
  )]
  <span class="kw">pub fn </span>method&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="self">self</span>: reference([a],[<span class="self">Self</span>]),idx: usize) -&gt; <span class="prelude-ty">Option</span>&lt;reference([a],[T])&gt; {
    <span class="self">self</span>.<span class="number">0</span>.method(idx)
  }
}</code></pre></div>
<p>Here we pass the lifetime <code>'a</code> to the substitution as the first argument,
and the type as the second. Notice how the arguments are separated by a
comma. This results in the following code:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;T&gt; VecWrap&lt;T&gt; {
  <span class="kw">pub fn </span>get&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="self">self</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="self">Self</span>, idx: usize) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>T&gt; {
    <span class="self">self</span>.<span class="number">0</span>.get(idx)
  }
  <span class="kw">pub fn </span>get_mut&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="self">self</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span><span class="self">Self</span>, idx: usize) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>T&gt; {
    <span class="self">self</span>.<span class="number">0</span>.get_mut(idx)
  }
}</code></pre></div>
<p>Notice also the way we pass lifetimes to identifiers: <code>reference([a], [Self])</code>. The lifetime is passed without the <code>'</code> prefix, which is instead
present in the substitution before the 	lifetime: <code>[&amp; 'lifetime type]</code>.
This is because the rust syntax disallows lifetimes in brackets on their
own. Our solution is therefore a hacking of the system and not a property of
<code>duplicate_item</code> itself.</p>
<h3 id="nested-invocation"><a href="#nested-invocation">Nested Invocation</a></h3>
<p>Imagine we have the following trait with the method <code>is_negative</code> that
should return <code>true</code> if the value of the object is negative and <code>false</code>
otherwise:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">trait </span>IsNegative {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool;
}</code></pre></div>
<p>We want to implement this for the six integer types <code>u8</code>, <code>u16</code>, <code>u32</code>,
<code>i8</code>, <code>i16</code>, and <code>i32</code>. For the first three types, which are all unsigned,
the implementation of this trait should trivially return <code>false</code> as they
can’t be negative. However, for the remaining, signed types their
implementations is identical (checking whether they are less than <code>0</code>), but,
of course, different from the first three:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>IsNegative <span class="kw">for </span>u8 {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="bool-val">false
  </span>}
}
<span class="kw">impl </span>IsNegative <span class="kw">for </span>u16 {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="bool-val">false
  </span>}
}
<span class="kw">impl </span>IsNegative <span class="kw">for </span>u32 {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="bool-val">false
  </span>}
}
<span class="kw">impl </span>IsNegative <span class="kw">for </span>i8 {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0
  </span>}
}
<span class="kw">impl </span>IsNegative <span class="kw">for </span>i16 {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0
  </span>}
}
<span class="kw">impl </span>IsNegative <span class="kw">for </span>i32 {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>&lt;  <span class="number">0
  </span>}
}</code></pre></div>
<p>Notice how the code repetition is split over 2 axes: 1) They all implement
the same trait 2) the method implementations of the first 3 are identical to
each other but different to the next 3, which are also mutually identical.
To implement this using only the syntax we have already seen, we could do
something like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  int_type implementation;
  [u8]     </span>[<span class="bool-val">false</span>];
  [u16]    [<span class="bool-val">false</span>];
  [u32]    [<span class="bool-val">false</span>];
  [i8]     [<span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0</span>];
  [i16]    [<span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0</span>];
  [i32]    [<span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0</span>]
)]
<span class="kw">impl </span>IsNegative <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    implementation
  }
}

<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i8</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i16</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i32</span>.is_negative());</code></pre></div>
<p>However, ironically, we here had to repeat ourselves in the macro invocation
instead of the code: we needed to repeat the implementations <code>[ false ]</code> and
<code>[ *self &lt; 0 ]</code> three times each. We can utilize <em>nested invocation</em> to
remove the last bit of repetition:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  int_type implementation;
  <span class="macro">duplicate!</span>{
    [
      int_type_nested; [u8]</span>; [u16]; [u32]
    ]
    [ int_type_nested ] [ <span class="bool-val">false </span>];
  }
  <span class="macro">duplicate!</span>{
    [
      int_type_nested; [i8]; [i16]; [i32]
    ]
    [ int_type_nested ] [ <span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0 </span>];
  }
)]
<span class="kw">impl </span>IsNegative <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    implementation
  }
}

<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i8</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i16</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i32</span>.is_negative());</code></pre></div>
<p>We use <code>duplicate!{..}</code> to invoke the macro inside itself.
In our example, we have 2 invocations that each produce 3 substitution
groups, inserting the correct <code>implementation</code> for their signed or unsigned
types. The above nested invocation is equivalent to the previous, non-nested
invocation, and actually expands to it as an intermediate step before
expanding the outer-most invocation.</p>
<p>Deeper levels of nested invocation are possible and work as expected.
There is no limit on the depth of nesting, however, as might be clear from
our example, it can get complicated to read.</p>
<p>Lastly, we should note that we can have nested invocations interleaved with
normal substitution groups. For example, say we want to implement
<code>IsNegative</code> for <code>i8</code>, but don’t want the same for <code>i16</code> and <code>i32</code>. We could
do the following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  int_type implementation;
  <span class="macro">duplicate!</span>{
    [                                     <span class="comment">// -+
      </span>int_type_nested; [u8]</span>; [u16]; [u32] <span class="comment">//  | Nested invocation producing 3
    </span>]                                     <span class="comment">//  | substitution groups
    </span>[int_type_nested ] [ <span class="bool-val">false </span>];         <span class="comment">//  |
  </span>}                                       <span class="comment">// -+
  </span>[ i8 ] [ <span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0 </span>]                    <span class="comment">// -- Substitution group 4
</span>)]
<span class="kw">impl </span>IsNegative <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    implementation
  }
}
</code></pre></div>
<p>In general, nested invocations can be used anywhere. However, note that
nested invocations are only recognized by the identifier <code>duplicate</code>,
followed by <code>!</code>, followed by a delimiter within which the nested invocation
is. Therefore, care must be taken to ensure the surrounding code is correct
after the expansion. E.g. maybe <code>;</code> is needed after the invocation, or
commas must be produced by the nested invocation itself as part of a list.</p>
<h3 id="verbose-syntax"><a href="#verbose-syntax">Verbose Syntax</a></h3>
<p>The syntax used in the previous examples is the <em>short syntax</em>.
<code>duplicate_item</code> also accepts a <em>verbose syntax</em> that is less concise, but
more readable in some circumstances. Using the verbose syntax, the very
first example above looks like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>duplicate::duplicate_item;
<span class="attr">#[duplicate_item(
  [
    int_type  [ u8 ]
    </span>max_value [ <span class="number">255 </span>]
  ]
  [
    int_type  [ u16 ]
    max_value [ <span class="number">65_535 </span>]
  ]
  [
    int_type  [ u32 ]
    max_value [ <span class="number">4_294_967_295 </span>]
  ]
)]
<span class="kw">impl </span>IsMax <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    <span class="kw-2">*</span><span class="self">self </span>== max_value
  }
}
</code></pre></div>
<p>In the verbose syntax, a substitution group is put inside ‘[]’ and
includes a list of substitution identifiers followed by their substitutions.
No <code>;</code>s are needed. Here is an annotated version of the same code:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  [                               <span class="comment">//-+
    </span>int_type  [ u8 ]              </span><span class="comment">// | Substitution group 1
    </span>max_value [ <span class="number">255 </span>]             <span class="comment">// |
//  ^^^^^^^^^ ^^^^^^^ substitution   |
//  |                                |
//  substitution identifier          |
  </span>]                               <span class="comment">//-+
  </span>[                               <span class="comment">//-+
    </span>int_type  [ u16 ]             <span class="comment">// | Substitution group 2
    </span>max_value [ <span class="number">65_535 </span>]          <span class="comment">// |
  </span>]                               <span class="comment">//-+
  </span>[                               <span class="comment">//-+
    </span>max_value [ <span class="number">4_294_967_295 </span>]   <span class="comment">// | Substitution group 3
    </span>int_type  [ u32 ]             <span class="comment">// |
  </span>]                               <span class="comment">//-+
</span>)]</code></pre></div>
<p>Note that in each substitution group every identifier must have exactly one
substitution. All the groups must have the exact same identifiers, though
the order in which they arrive in each group is not important. For example,
in the annotated example, the third group has the <code>max_value</code> identifier
before <code>int_type</code> without having any effect on the expanded code.</p>
<p>The verbose syntax is not very concise but it has some advantages over
the short syntax in regards to readability. Using many identifiers and
long substitutions can quickly become unwieldy in the short syntax.
The verbose syntax deals better with both cases as it will grow horizontally
instead of vertically.</p>
<p>The verbose syntax also offers nested invocation. The syntax is exactly the
same, but since there is no initial substitution identifier list, nested
calls can be used anywhere (though still not inside substitution groups.)
The previous <code>IsNegative</code> nested invocation example can be written as
follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  <span class="macro">duplicate!</span>{
    [ int_type_nested; [u8]</span>; [u16]; [u32] ]
    [
      int_type [ int_type_nested ]
      implementation [ <span class="bool-val">false </span>]
    ]
  }
  <span class="macro">duplicate!</span>{
    [ int_type_nested; [i8]; [i16]; [i32] ]
    [
      int_type [ int_type_nested ]
      implementation [ <span class="kw-2">*</span><span class="self">self </span>&lt; <span class="number">0 </span>]
    ]
  }
)]
<span class="kw">impl </span>IsNegative <span class="kw">for </span>int_type {
  <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
    implementation
  }
}

<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i8</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i16</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42i32</span>.is_negative());</code></pre></div>
<p>It’s important to notice that the nested invocation doesn’t know it
isn’t the outer-most invocation and therefore doesn’t discriminate between
identifiers. We had to use a different identifier in the nested invocations
(<code>int_type_nested</code>) than in the code (<code>int_type</code>), because otherwise the
nested invocation would substitute the substitution identifier too, instead
of only substituting in the nested invocation’s substitute.</p>
<p>Nested invocations must produce the syntax of their
parent invocation. However, each invocation’s private syntax is free
to use any syntax type. Notice in our above example, the nested
invocations use short syntax but produce verbose syntax for the outer-most
invocation.</p>
<h3 id="global-substitutions"><a href="#global-substitutions">Global Substitutions</a></h3>
<p>Say we have a function that takes two types as inputs and returns the same
types as output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>some_func(
  arg1: <span class="prelude-val">Some</span>&lt;Complex&lt;()&gt;, Type&lt;WeDont&lt;Want, To, Repeat&gt;&gt;&gt;,
  arg2: <span class="prelude-val">Some</span>&lt;Other, Complex&lt;Type&lt;(To, Repeat)&gt;&gt;&gt;)
  -&gt; (
    <span class="prelude-val">Some</span>&lt;Complex&lt;()&gt;, Type&lt;WeDont&lt;Want, To, Repeat&gt;&gt;&gt;,
    <span class="prelude-val">Some</span>&lt;Other, Complex&lt;Type&lt;(To, Repeat)&gt;&gt;&gt;
  )
{
  ...
}</code></pre></div>
<p>Using global substitution, we can avoid repeating the types:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  typ1 [<span class="prelude-val">Some</span>&lt;Complex&lt;()&gt;, Type&lt;WeDont&lt;Want, To, Repeat&gt;&gt;&gt;]</span>;
  typ2 [<span class="prelude-val">Some</span>&lt;Other, Complex&lt;Type&lt;(To, Repeat)&gt;&gt;&gt;];
)]
<span class="kw">fn </span>some_func(arg1: typ1, arg2: typ2) -&gt; (typ1, typ2){
  ...
}</code></pre></div>
<p>Here we have defined the two global substitution variables <code>typ1</code> and
<code>typ2</code>, and used them in the function definition. Global substitutions have
the same syntax as verbose syntax substitution (identifier, optionally
followed by parameters, followed by a substitution.) In our example, no
short or verbose syntax substitution groups are given. While this is not
usually allowed, since we have given at least one global substitution, the
item will simply be kept as is, except with the global substitutions.</p>
<p>We can follow global substitutions by substitution groups to achieve
duplication too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  typ1 [<span class="prelude-val">Some</span>&lt;Complex&lt;()&gt;, Type&lt;WeDont&lt;Want, To, Repeat&gt;&gt;&gt;]</span>;
  typ2 [<span class="prelude-val">Some</span>&lt;Other, Complex&lt;Type&lt;(To, Repeat)&gt;&gt;&gt;];
  method     reference(<span class="kw">type</span>);
  [get]      [&amp; <span class="kw">type</span>];
  [get_mut]  [<span class="kw-2">&amp;mut </span><span class="kw">type</span>];
)]
<span class="kw">fn </span>method(
  arg0: reference([Type&lt;()&gt;]),
  arg1: typ1,
  arg2: typ2)
  -&gt; (reference([typ1]), reference([typ2]))
{
  ...
}</code></pre></div>
<p>Here we duplicate the function to use either shared or mutable reference,
while reusing <code>typ1</code> and <code>typ2</code> in both duplicates.</p>
<p>The following additional rules apply when using global substitutions:</p>
<ul>
<li>All global substitutions must come before any short or verbose syntax
substitution groups.</li>
<li>Global substitution variable are <strong>not</strong> substituted inside the bodies of
following substitutions. If that is needed, multiple invocations can be
used.</li>
<li>All global substitutions must be separated by <code>;</code>, also when followed by
substitution groups.</li>
</ul>
<h2 id="crate-features"><a href="#crate-features">Crate Features</a></h2><h4 id="module_disambiguation"><a href="#module_disambiguation"><code>module_disambiguation</code></a></h4>
<p><strong>Implicit Module Name Disambiguation</strong> (Enabled by default)</p>
<p>It is sometime beneficial to apply <code>duplicate_item</code> to a module, such that
all its contents are duplicated at once. However, this will always need the
resulting modules to have unique names to avoid the compiler issueing an
error. Without <code>module_disambiguation</code>, module names must be substituted
manually. With <code>module_disambiguation</code>, the following will compile
successfully:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[duplicate_item(
  int_type  max_value;
  [ u8 ]    </span>[ <span class="number">255 </span>];
  [ u16 ]   [ <span class="number">65_535 </span>];
  [ u32 ]   [ <span class="number">4_294_967_295 </span>];
)]
<span class="kw">mod </span>module {
  <span class="kw">impl </span>IsMax <span class="kw">for </span>int_type {
    <span class="kw">fn </span>is_max(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
      <span class="kw-2">*</span><span class="self">self </span>== max_value
    }
  }
  <span class="kw">impl </span>IsNegative <span class="kw">for </span>int_type {
    <span class="kw">fn </span>is_negative(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
      <span class="bool-val">false
    </span>}
  }
}

<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_max());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_max());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_max());
<span class="macro">assert!</span>(!<span class="number">42u8</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u16</span>.is_negative());
<span class="macro">assert!</span>(!<span class="number">42u32</span>.is_negative());</code></pre></div>
<p>This works because the three duplicate modules get assigned unique names:
<code>module_u8</code>, <code>module_u16</code>, and <code>module_u32</code>. However, this only works if a
substitution identifier can be found, where all its substitutions only
produce a single identifier and nothing else. Those identifiers are then
converted to snake case, and postfixed to the original module’s name,
e.g., <code>module  + u8 = module_u8</code>. The first suitable substitution
identifier is chosen.</p>
<p>Notes:</p>
<ul>
<li>The exact way unique names are generated is not part of any stability
guarantee and should not be depended upon. It may change in the future
without bumping the major version.</li>
<li>Only the name of the module is substituted with the disambiguated name.
Any matching identifier in the body of the module is ignored.</li>
</ul>
<h4 id="pretty_errors"><a href="#pretty_errors"><code>pretty_errors</code></a></h4>
<p><strong>More Detailed Error Messages</strong> (Enabled by default)</p>
<p>Enabling this feature will make error messages indicate exactly where the
offending code is. Without this feature, error messages will not provide
detailed location indicators for errors.</p>
<p>This feature is has no effect on expansion. Therefore, libraries are advised
to keep this feature off (note that it’s enabled by default)
to avoid forcing it on users.</p>
<h2 id="disclaimer"><a href="#disclaimer">Disclaimer</a></h2>
<p>This crate does not try to justify or condone the usage of code duplication
instead of proper abstractions.
This crate should only be used where it is not possible to reduce code
duplication through other means, or where it simply is not worth it.</p>
<p>As an example, libraries that have two or more structs/traits with similar
APIs might use this macro to test them without having to copy-paste test
cases and manually make the needed edits.</p>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.duplicate.html" title="macro duplicate::duplicate">duplicate</a></div><div class="desc docblock-short">Duplicates the given code and substitutes specific identifiers
for different code snippets in each duplicate.</div></li></ul><h2 id="attributes" class="small-section-header"><a href="#attributes">Attribute Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.duplicate_item.html" title="attr duplicate::duplicate_item">duplicate_item</a></div><div class="desc docblock-short">Duplicates the item and substitutes specific identifiers for different code
snippets in each duplicate.</div></li></ul></section></div></main></body></html>