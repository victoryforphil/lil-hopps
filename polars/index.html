<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Polars: DataFrames in Rust"><title>polars - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="polars" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.1 (a28077b28 2023-12-04)" data-channel="1.74.1" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../polars/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../polars/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate polars</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.35.4</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#constants">Constants</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">polars</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/polars/lib.rs.html#1-425">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="polars-dataframes-in-rust"><a href="#polars-dataframes-in-rust">Polars: <em><small>DataFrames in Rust</small></em></a></h2>
<p>Polars is a DataFrame library for Rust. It is based on <a href="https://arrow.apache.org/">Apache Arrow</a>’s memory model.
Apache arrow provides very cache efficient columnar data structures and is becoming the defacto
standard for columnar data.</p>
<h3 id="quickstart"><a href="#quickstart">Quickstart</a></h3>
<p>We recommend to build your queries directly with <a href="../polars_lazy/index.html" title="mod polars_lazy">polars-lazy</a>. This allows you to combine
expression into powerful aggregations and column selections. All expressions are evaluated
in parallel and your queries are optimized just in time.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>polars::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>lf1 = LazyFrame::scan_parquet(<span class="string">&quot;myfile_1.parquet&quot;</span>, Default::default())<span class="question-mark">?
    </span>.group_by([col(<span class="string">&quot;ham&quot;</span>)])
    .agg([
        <span class="comment">// expressions can be combined into powerful aggregations
        </span>col(<span class="string">&quot;foo&quot;</span>)
            .sort_by([col(<span class="string">&quot;ham&quot;</span>).rank(Default::default(), <span class="prelude-val">None</span>)], [<span class="bool-val">false</span>])
            .last()
            .alias(<span class="string">&quot;last_foo_ranked_by_ham&quot;</span>),
        <span class="comment">// every expression runs in parallel
        </span>col(<span class="string">&quot;foo&quot;</span>).cum_min(<span class="bool-val">false</span>).alias(<span class="string">&quot;cumulative_min_per_group&quot;</span>),
        <span class="comment">// every expression runs in parallel
        </span>col(<span class="string">&quot;foo&quot;</span>).reverse().implode().alias(<span class="string">&quot;reverse_group&quot;</span>),
    ]);

<span class="kw">let </span>lf2 = LazyFrame::scan_parquet(<span class="string">&quot;myfile_2.parquet&quot;</span>, Default::default())<span class="question-mark">?
    </span>.select([col(<span class="string">&quot;ham&quot;</span>), col(<span class="string">&quot;spam&quot;</span>)]);

<span class="kw">let </span>df = lf1
    .join(lf2, [col(<span class="string">&quot;reverse&quot;</span>)], [col(<span class="string">&quot;foo&quot;</span>)], JoinArgs::new(JoinType::Left))
    <span class="comment">// now we finally materialize the result.
    </span>.collect()<span class="question-mark">?</span>;</code></pre></div>
<p>This means that Polars data structures can be shared zero copy with processes in many different
languages.</p>
<h3 id="tree-of-contents"><a href="#tree-of-contents">Tree Of Contents</a></h3>
<ul>
<li><a href="#cookbooks">Cookbooks</a></li>
<li><a href="#data-structures">Data structures</a>
<ul>
<li><a href="#dataframe">DataFrame</a></li>
<li><a href="#series">Series</a></li>
<li><a href="#chunkedarray">ChunkedArray</a></li>
</ul>
</li>
<li><a href="#simd">SIMD</a></li>
<li><a href="#api">API</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#compile-times">Compile times</a></li>
<li><a href="#performance-and-string-data">Performance</a>
<ul>
<li><a href="#custom-allocator">Custom allocator</a></li>
</ul>
</li>
<li><a href="#config-with-env-vars">Config</a></li>
<li><a href="#user-guide">User Guide</a></li>
</ul>
<h3 id="cookbooks"><a href="#cookbooks">Cookbooks</a></h3>
<p>See examples in the cookbooks:</p>
<ul>
<li><a href="docs/eager/index.html" title="mod polars::docs::eager">Eager</a></li>
<li><a href="docs/lazy/index.html" title="mod polars::docs::lazy">Lazy</a></li>
</ul>
<h3 id="data-structures"><a href="#data-structures">Data Structures</a></h3>
<p>The base data structures provided by polars are <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a>, <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>, and <a href="chunked_array/struct.ChunkedArray.html" title="struct polars::chunked_array::ChunkedArray"><code>ChunkedArray&lt;T&gt;</code></a>.
We will provide a short, top-down view of these data structures.</p>
<h4 id="dataframe"><a href="#dataframe">DataFrame</a></h4>
<p>A <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> is a 2 dimensional data structure that is backed by a <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>, and it could be
seen as an abstraction on <a href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec&lt;Series&gt;</code></a>. Operations that can be executed on <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> are very
similar to what is done in a <code>SQL</code> like query. You can <code>GROUP</code>, <code>JOIN</code>, <code>PIVOT</code> etc.</p>
<h4 id="series"><a href="#series">Series</a></h4>
<p><a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> are the type agnostic columnar data representation of Polars. They provide many
operations out of the box, many via the <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> series and
<a href="series/trait.SeriesTrait.html" title="trait polars::series::SeriesTrait"><code>SeriesTrait</code></a> trait. Whether or not an operation is provided
by a <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> is determined by the operation. If the operation can be done without knowing the
underlying columnar type, this operation probably is provided by the <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>. If not, you must
downcast to the typed data structure that is wrapped by the <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>. That is the <a href="chunked_array/struct.ChunkedArray.html" title="struct polars::chunked_array::ChunkedArray"><code>ChunkedArray&lt;T&gt;</code></a>.</p>
<h4 id="chunkedarray"><a href="#chunkedarray">ChunkedArray</a></h4>
<p><a href="chunked_array/struct.ChunkedArray.html" title="struct polars::chunked_array::ChunkedArray"><code>ChunkedArray&lt;T&gt;</code></a> are wrappers around an arrow array, that can contain multiples chunks, e.g.
<a href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec&lt;dyn ArrowArray&gt;</code></a>. These are the root data structures of Polars, and implement many operations.
Most operations are implemented by traits defined in <a href="chunked_array/ops/index.html" title="mod polars::chunked_array::ops">chunked_array::ops</a>,
or on the <a href="chunked_array/struct.ChunkedArray.html" title="struct polars::chunked_array::ChunkedArray"><code>ChunkedArray</code></a> struct.</p>
<h3 id="simd"><a href="#simd">SIMD</a></h3>
<p>Polars / Arrow uses packed_simd to speed up kernels with SIMD operations. SIMD is an optional
<code>feature = &quot;nightly&quot;</code>, and requires a nightly compiler. If you don’t need SIMD, <strong>Polars runs on stable!</strong></p>
<h3 id="api"><a href="#api">API</a></h3>
<p>Polars supports an eager and a lazy API. The eager API directly yields results, but is overall
more verbose and less capable of building elegant composite queries. We recommend to use the Lazy API
whenever you can.</p>
<p>As neither API is async they should be wrapped in <em>spawn_blocking</em> when used in an async context
to avoid blocking the async thread pool of the runtime.</p>
<h3 id="expressions"><a href="#expressions">Expressions</a></h3>
<p>Polars has a powerful concept called expressions.
Polars expressions can be used in various contexts and are a functional mapping of
<code>Fn(Series) -&gt; Series</code>, meaning that they have <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> as input and <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> as output.
By looking at this functional definition, we can see that the output of an <a href="prelude/enum.Expr.html" title="enum polars::prelude::Expr"><code>Expr</code></a> also can serve
as the input of an <a href="prelude/enum.Expr.html" title="enum polars::prelude::Expr"><code>Expr</code></a>.</p>
<p>That may sound a bit strange, so lets give an example. The following is an expression:</p>
<p><code>col(&quot;foo&quot;).sort().head(2)</code></p>
<p>The snippet above says select column <code>&quot;foo&quot;</code> then sort this column and then take first 2 values
of the sorted output.
The power of expressions is that every expression produces a new expression and that they can
be piped together.
You can run an expression by passing them on one of polars execution contexts.
Here we run two expressions in the <strong>select</strong> context:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  df.lazy()
   .select([
       col(<span class="string">&quot;foo&quot;</span>).sort(Default::default()).head(<span class="prelude-val">None</span>),
       col(<span class="string">&quot;bar&quot;</span>).filter(col(<span class="string">&quot;foo&quot;</span>).eq(lit(<span class="number">1</span>))).sum(),
   ])
   .collect()<span class="question-mark">?</span>;</code></pre></div>
<p>All expressions are ran in parallel, meaning that separate polars expressions are embarrassingly parallel.
(Note that within an expression there may be more parallelization going on).</p>
<p>Understanding polars expressions is most important when starting with the polars library. Read more
about them in the <a href="https://pola-rs.github.io/polars/user-guide/concepts/expressions">User Guide</a>.
Though the examples given there are in python. The expressions API is almost identical and the
the read should certainly be valuable to rust users as well.</p>
<h4 id="eager"><a href="#eager">Eager</a></h4>
<p>Read more in the pages of the following data structures /traits.</p>
<ul>
<li><a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame">DataFrame struct</a></li>
<li><a href="series/struct.Series.html" title="struct polars::series::Series">Series struct</a></li>
<li><a href="series/trait.SeriesTrait.html" title="trait polars::series::SeriesTrait">Series trait</a></li>
<li><a href="chunked_array/struct.ChunkedArray.html" title="struct polars::chunked_array::ChunkedArray">ChunkedArray struct</a></li>
<li><a href="chunked_array/ops/index.html" title="mod polars::chunked_array::ops">ChunkedArray operations traits</a></li>
</ul>
<h4 id="lazy"><a href="#lazy">Lazy</a></h4>
<p>Unlock full potential with lazy computation. This allows query optimizations and provides Polars
the full query context so that the fastest algorithm can be chosen.</p>
<p><strong><a href="../polars_lazy/index.html" title="mod polars_lazy">Read more in the lazy module.</a></strong></p>
<h3 id="compile-times"><a href="#compile-times">Compile times</a></h3>
<p>A DataFrame library typically consists of</p>
<ul>
<li>Tons of features</li>
<li>A lot of datatypes</li>
</ul>
<p>Both of these really put strain on compile times. To keep Polars lean, we make both <strong>opt-in</strong>,
meaning that you only pay the compilation cost, if you need it.</p>
<h3 id="compile-times-and-opt-in-features"><a href="#compile-times-and-opt-in-features">Compile times and opt-in features</a></h3>
<p>The opt-in features are (not including dtype features):</p>
<ul>
<li><code>performant</code> - Longer compile times more fast paths.</li>
<li><code>lazy</code> - Lazy API
<ul>
<li><code>lazy_regex</code> - Use regexes in <a href="prelude/fn.col.html" title="fn polars::prelude::col">column selection</a></li>
<li><code>dot_diagram</code> - Create dot diagrams from lazy logical plans.</li>
</ul>
</li>
<li><code>sql</code> - Pass SQL queries to polars.</li>
<li><code>streaming</code> - Be able to process datasets that are larger than RAM.</li>
<li><code>random</code> - Generate arrays with randomly sampled values</li>
<li><code>ndarray</code>- Convert from <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> to <a href="https://docs.rs/ndarray/">ndarray</a></li>
<li><code>temporal</code> - Conversions between <a href="https://docs.rs/chrono/">Chrono</a> and Polars for temporal data types</li>
<li><code>timezones</code> - Activate timezone support.</li>
<li><code>strings</code> - Extra string utilities for <a href="datatypes/type.Utf8Chunked.html" title="type polars::datatypes::Utf8Chunked"><code>Utf8Chunked</code></a> //!     - <code>string_pad</code> - <code>zfill</code>, <code>ljust</code>, <code>rjust</code>
<ul>
<li><code>string_to_integer</code> - <code>parse_int</code></li>
</ul>
</li>
<li><code>object</code> - Support for generic ChunkedArrays called <a href="polars_core::datatypes::ObjectChunked"><code>ObjectChunked&lt;T&gt;</code></a> (generic over <code>T</code>).
These are downcastable from Series through the <a href="https://doc.rust-lang.org/std/any/index.html">Any</a> trait.</li>
<li>Performance related:
<ul>
<li><code>nightly</code> - Several nightly only features such as SIMD and specialization.</li>
<li><code>performant</code> - more fast paths, slower compile times.</li>
<li><code>bigidx</code> - Activate this feature if you expect &gt;&gt; 2^32 rows. This has not been needed by anyone.
This allows polars to scale up way beyond that by using <code>u64</code> as an index.
Polars will be a bit slower with this feature activated as many data structures
are less cache efficient.</li>
<li><code>cse</code> - Activate common subplan elimination optimization</li>
</ul>
</li>
<li>IO related:
<ul>
<li><code>serde</code> - Support for <a href="https://crates.io/crates/serde">serde</a> serialization and deserialization.
Can be used for JSON and more serde supported serialization formats.</li>
<li><code>serde-lazy</code> - Support for <a href="https://crates.io/crates/serde">serde</a> serialization and deserialization.
Can be used for JSON and more serde supported serialization formats.</li>
<li><code>parquet</code> - Read Apache Parquet format</li>
<li><code>json</code> - JSON serialization</li>
<li><code>ipc</code> - Arrow’s IPC format serialization</li>
<li><code>decompress</code> - Automatically infer compression of csvs and decompress them.
Supported compressions:
* zip
* gzip</li>
</ul>
</li>
</ul>
<ul>
<li><a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> operations:
<ul>
<li><code>dynamic_group_by</code> - Groupby based on a time window instead of predefined keys.
Also activates rolling window group by operations.</li>
<li><code>sort_multiple</code> - Allow sorting a <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> on multiple columns</li>
<li><code>rows</code> - Create <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> from rows and extract rows from <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a>s.
And activates <code>pivot</code> and <code>transpose</code> operations</li>
<li><code>asof_join</code> - Join ASOF, to join on nearest keys instead of exact equality match.</li>
<li><code>cross_join</code> - Create the cartesian product of two <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a>s.</li>
<li><code>semi_anti_join</code> - SEMI and ANTI joins.</li>
<li><code>group_by_list</code> - Allow group_by operation on keys of type List.</li>
<li><code>row_hash</code> - Utility to hash <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> rows to <a href="datatypes/type.UInt64Chunked.html" title="type polars::datatypes::UInt64Chunked"><code>UInt64Chunked</code></a></li>
<li><code>diagonal_concat</code> - Concat diagonally thereby combining different schemas.</li>
<li><code>horizontal_concat</code> - Concat horizontally and extend with null values if lengths don’t match</li>
<li><code>dataframe_arithmetic</code> - Arithmetic on (<a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>Dataframe</code></a> and <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a>s) and (<a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> on <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>)</li>
<li><code>partition_by</code> - Split into multiple <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a>s partitioned by groups.</li>
</ul>
</li>
<li><a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>/<a href="prelude/enum.Expr.html" title="enum polars::prelude::Expr"><code>Expr</code></a> operations:
<ul>
<li><code>is_in</code> - Check for membership in <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>.</li>
<li><code>zip_with</code> - <a href="chunked_array/ops/trait.ChunkZip.html" title="trait polars::chunked_array::ops::ChunkZip">Zip two Series/ ChunkedArrays</a>.</li>
<li><code>round_series</code> - round underlying float types of <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>.</li>
<li><code>repeat_by</code> - [Repeat element in an Array N times, where N is given by another array.</li>
<li><code>is_first_distinct</code> - Check if element is first unique value.</li>
<li><code>is_last_distinct</code> - Check if element is last unique value.</li>
<li><code>checked_arithmetic</code> - checked arithmetic/ returning <a href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> on invalid operations.</li>
<li><code>dot_product</code> - Dot/inner product on <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> and <a href="prelude/enum.Expr.html" title="enum polars::prelude::Expr"><code>Expr</code></a>.</li>
<li><code>concat_str</code> - Concat string data in linear time.</li>
<li><code>reinterpret</code> - Utility to reinterpret bits to signed/unsigned</li>
<li><code>take_opt_iter</code> - Take from a <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> with <a href="https://doc.rust-lang.org/1.74.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator&lt;Item=Option&lt;usize&gt;&gt;</code></a>.</li>
<li><code>mode</code> - <a href="polars_ops::chunked_array::mode">Return the most occurring value(s)</a></li>
<li><code>cum_agg</code> - <a href="polars_ops::prelude::cum_sum"><code>cum_sum</code></a>, <a href="polars_ops::prelude::cum_min"><code>cum_min</code></a>, <a href="polars_ops::prelude::cum_max"><code>cum_max</code></a> aggregation.</li>
<li><code>rolling_window</code> - rolling window functions, like <a href="series/struct.Series.html#method.rolling_mean" title="struct polars::series::Series"><code>rolling_mean</code></a></li>
<li><code>interpolate</code> <a href="polars_ops::chunked_array::interpolate">interpolate None values</a></li>
<li><code>extract_jsonpath</code> - <a href="https://goessner.net/articles/JsonPath/">Run jsonpath queries on Utf8Chunked</a></li>
<li><code>list</code> - List utils.
<ul>
<li><code>list_gather</code> take sublist by multiple indices</li>
</ul>
</li>
<li><code>rank</code> - Ranking algorithms.</li>
<li><code>moment</code> - kurtosis and skew statistics</li>
<li><code>ewma</code> - Exponential moving average windows</li>
<li><code>abs</code> - Get absolute values of <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>.</li>
<li><code>arange</code> - Range operation on <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>.</li>
<li><code>product</code> - Compute the product of a <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>.</li>
<li><code>diff</code> - <a href="polars_ops::prelude::diff"><code>diff</code></a> operation.</li>
<li><code>pct_change</code> - Compute change percentages.</li>
<li><code>unique_counts</code> - Count unique values in expressions.</li>
<li><code>log</code> - Logarithms for <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>.</li>
<li><code>list_to_struct</code> - Convert <a href="datatypes/enum.DataType.html#variant.List" title="variant polars::datatypes::DataType::List"><code>List</code></a> to <a href="crate::datatypes::DataType::Struct"><code>Struct</code></a> dtypes.</li>
<li><code>list_count</code> - Count elements in lists.</li>
<li><code>list_eval</code> - Apply expressions over list elements.</li>
<li><code>list_sets</code> - Compute UNION, INTERSECTION, and DIFFERENCE on list types.</li>
<li><code>cumulative_eval</code> - Apply expressions over cumulatively increasing windows.</li>
<li><code>arg_where</code> - Get indices where condition holds.</li>
<li><code>search_sorted</code> - Find indices where elements should be inserted to maintain order.</li>
<li><code>date_offset</code> - Add an offset to dates that take months and leap years into account.</li>
<li><code>trigonometry</code> - Trigonometric functions.</li>
<li><code>sign</code> - Compute the element-wise sign of a <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>.</li>
<li><code>propagate_nans</code> - NaN propagating min/max aggregations.</li>
<li><code>extract_groups</code> - Extract multiple regex groups from strings.</li>
<li><code>cov</code> - Covariance and correlation functions.</li>
</ul>
</li>
<li><a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> pretty printing
<ul>
<li><code>fmt</code> - Activate <a href="frame/struct.DataFrame.html" title="struct polars::frame::DataFrame"><code>DataFrame</code></a> formatting</li>
</ul>
</li>
</ul>
<h3 id="compile-times-and-opt-in-data-types"><a href="#compile-times-and-opt-in-data-types">Compile times and opt-in data types</a></h3>
<p>As mentioned above, Polars <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> are wrappers around
<a href="chunked_array/struct.ChunkedArray.html" title="struct polars::chunked_array::ChunkedArray"><code>ChunkedArray&lt;T&gt;</code></a> without the generic parameter <code>T</code>.
To get rid of the generic parameter, all the possible value of <code>T</code> are compiled
for <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>. This gets more expensive the more types you want for a <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a>. In order to reduce
the compile times, we have decided to default to a minimal set of types and make more <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> types
opt-in.</p>
<p>Note that if you get strange compile time errors, you probably need to opt-in for that <a href="series/struct.Series.html" title="struct polars::series::Series"><code>Series</code></a> dtype.
The opt-in dtypes are:</p>
<div><table><thead><tr><th>data type</th><th>feature flag</th></tr></thead><tbody>
<tr><td>Date</td><td>dtype-date</td></tr>
<tr><td>Datetime</td><td>dtype-datetime</td></tr>
<tr><td>Time</td><td>dtype-time</td></tr>
<tr><td>Duration</td><td>dtype-duration</td></tr>
<tr><td>Int8</td><td>dtype-i8</td></tr>
<tr><td>Int16</td><td>dtype-i16</td></tr>
<tr><td>UInt8</td><td>dtype-u8</td></tr>
<tr><td>UInt16</td><td>dtype-u16</td></tr>
<tr><td>Categorical</td><td>dtype-categorical</td></tr>
<tr><td>Struct</td><td>dtype-struct</td></tr>
</tbody></table>
</div>
<p>Or you can choose on of the preconfigured pre-sets.</p>
<ul>
<li><code>dtype-full</code> - all opt-in dtypes.</li>
<li><code>dtype-slim</code> - slim preset of opt-in dtypes.</li>
</ul>
<h3 id="performance-and-string-data"><a href="#performance-and-string-data">Performance and string data</a></h3>
<p>Large string data can really slow down your queries.
Read more in the <a href="docs/performance/index.html" title="mod polars::docs::performance">performance section</a></p>
<h4 id="custom-allocator"><a href="#custom-allocator">Custom allocator</a></h4>
<p>A DataFrame library naturally does a lot of heap allocations. It is recommended to use a custom
allocator.
<a href="https://crates.io/crates/mimalloc">Mimalloc</a> and
<a href="https://crates.io/crates/jemallocator">JeMalloc</a> for instance, show a significant
performance gain in runtime as well as memory usage.</p>
<h5 id="usage"><a href="#usage">Usage</a></h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mimalloc::MiMalloc;

<span class="attr">#[global_allocator]
</span><span class="kw">static </span>GLOBAL: MiMalloc = MiMalloc;</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jemallocator::Jemalloc;

<span class="attr">#[global_allocator]
</span><span class="kw">static </span>GLOBAL: Jemalloc = Jemalloc;</code></pre></div>
<h5 id="notes"><a href="#notes">Notes</a></h5>
<p><a href="https://github.com/pola-rs/polars/pull/3108">Benchmarks</a> have shown that on Linux JeMalloc
outperforms Mimalloc on all tasks and is therefore the default Linux allocator used for the Python bindings.</p>
<h5 id="cargotoml"><a href="#cargotoml">Cargo.toml</a></h5><div class="example-wrap"><pre class="language-toml"><code>[dependencies]
mimalloc = { version = &quot;*&quot;, default-features = false }
</code></pre></div><h3 id="config-with-env-vars"><a href="#config-with-env-vars">Config with ENV vars</a></h3>
<ul>
<li><code>POLARS_FMT_TABLE_FORMATTING</code> -&gt; define styling of tables using any of the following options (default = UTF8_FULL_CONDENSED). These options are defined by comfy-table which provides examples for each at <a href="https://github.com/Nukesor/comfy-table/blob/main/src/style/presets.rs">https://github.com/Nukesor/comfy-table/blob/main/src/style/presets.rs</a>
<ul>
<li><code>ASCII_FULL</code></li>
<li><code>ASCII_FULL_CONDENSED</code></li>
<li><code>ASCII_NO_BORDERS</code></li>
<li><code>ASCII_BORDERS_ONLY</code></li>
<li><code>ASCII_BORDERS_ONLY_CONDENSED</code></li>
<li><code>ASCII_HORIZONTAL_ONLY</code></li>
<li><code>ASCII_MARKDOWN</code></li>
<li><code>UTF8_FULL</code></li>
<li><code>UTF8_FULL_CONDENSED</code></li>
<li><code>UTF8_NO_BORDERS</code></li>
<li><code>UTF8_BORDERS_ONLY</code></li>
<li><code>UTF8_HORIZONTAL_ONLY</code></li>
<li><code>NOTHING</code></li>
</ul>
</li>
<li><code>POLARS_FMT_TABLE_CELL_ALIGNMENT</code> -&gt; define cell alignment using any of the following options (default = LEFT):
<ul>
<li><code>LEFT</code></li>
<li><code>CENTER</code></li>
<li><code>RIGHT</code></li>
</ul>
</li>
<li><code>POLARS_FMT_TABLE_DATAFRAME_SHAPE_BELOW</code> -&gt; print shape information below the table.</li>
<li><code>POLARS_FMT_TABLE_HIDE_COLUMN_NAMES</code> -&gt; hide table column names.</li>
<li><code>POLARS_FMT_TABLE_HIDE_COLUMN_DATA_TYPES</code> -&gt; hide data types for columns.</li>
<li><code>POLARS_FMT_TABLE_HIDE_COLUMN_SEPARATOR</code> -&gt; hide separator that separates column names from rows.</li>
<li><code>POLARS_FMT_TABLE_HIDE_DATAFRAME_SHAPE_INFORMATION&quot;</code> -&gt; omit table shape information.</li>
<li><code>POLARS_FMT_TABLE_INLINE_COLUMN_DATA_TYPE</code> -&gt; put column data type on the same line as the column name.</li>
<li><code>POLARS_FMT_TABLE_ROUNDED_CORNERS</code> -&gt; apply rounded corners to UTF8-styled tables.</li>
<li><code>POLARS_FMT_MAX_COLS</code> -&gt; maximum number of columns shown when formatting DataFrames.</li>
<li><code>POLARS_FMT_MAX_ROWS</code> -&gt; maximum number of rows shown when formatting DataFrames, <code>-1</code> to show all.</li>
<li><code>POLARS_FMT_STR_LEN</code> -&gt; maximum number of characters printed per string value.</li>
<li><code>POLARS_TABLE_WIDTH</code> -&gt; width of the tables used during DataFrame formatting.</li>
<li><code>POLARS_MAX_THREADS</code> -&gt; maximum number of threads used to initialize thread pool (on startup).</li>
<li><code>POLARS_VERBOSE</code> -&gt; print logging info to stderr.</li>
<li><code>POLARS_NO_PARTITION</code> -&gt; polars may choose to partition the group_by operation, based on data
cardinality. Setting this env var will turn partitioned group_by’s off.</li>
<li><code>POLARS_PARTITION_UNIQUE_COUNT</code> -&gt; at which (estimated) key count a partitioned group_by should run.
defaults to <code>1000</code>, any higher cardinality will run default group_by.</li>
<li><code>POLARS_FORCE_PARTITION</code> -&gt; force partitioned group_by if the keys and aggregations allow it.</li>
<li><code>POLARS_ALLOW_EXTENSION</code> -&gt; allows for <a href="polars_core::datatypes::ObjectChunked"><code>ObjectChunked&lt;T&gt;</code></a> to be used in arrow, opening up possibilities like using
<code>T</code> in complex lazy expressions. However this does require <code>unsafe</code> code allow this.</li>
<li><code>POLARS_NO_PARQUET_STATISTICS</code> -&gt; if set, statistics in parquet files are ignored.</li>
<li><code>POLARS_PANIC_ON_ERR</code> -&gt; panic instead of returning an Error.</li>
<li><code>POLARS_NO_CHUNKED_JOIN</code> -&gt; force rechunk before joins.</li>
</ul>
<h3 id="user-guide"><a href="#user-guide">User Guide</a></h3>
<p>If you want to read more, <a href="https://pola-rs.github.io/polars/">check the User Guide</a>.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.io"><code>pub use <a class="mod" href="../polars_io/index.html" title="mod polars_io">polars_io</a> as io;</code></div></li><li><div class="item-name" id="reexport.lazy"><code>pub use <a class="mod" href="../polars_lazy/index.html" title="mod polars_lazy">polars_lazy</a> as lazy;</code></div></li><li><div class="item-name" id="reexport.time"><code>pub use <a class="mod" href="../polars_time/index.html" title="mod polars_time">polars_time</a> as time;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="chunked_array/index.html" title="mod polars::chunked_array">chunked_array</a></div><div class="desc docblock-short">The typed heart of every Series column.</div></li><li><div class="item-name"><a class="mod" href="datatypes/index.html" title="mod polars::datatypes">datatypes</a></div><div class="desc docblock-short">Data types supported by Polars.</div></li><li><div class="item-name"><a class="mod" href="docs/index.html" title="mod polars::docs">docs</a></div></li><li><div class="item-name"><a class="mod" href="error/index.html" title="mod polars::error">error</a></div></li><li><div class="item-name"><a class="mod" href="frame/index.html" title="mod polars::frame">frame</a></div><div class="desc docblock-short">DataFrame module.</div></li><li><div class="item-name"><a class="mod" href="functions/index.html" title="mod polars::functions">functions</a></div><div class="desc docblock-short">Functions</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod polars::prelude">prelude</a></div></li><li><div class="item-name"><a class="mod" href="series/index.html" title="mod polars::series">series</a></div><div class="desc docblock-short">Type agnostic columnar data structure.</div></li><li><div class="item-name"><a class="mod" href="testing/index.html" title="mod polars::testing">testing</a></div><div class="desc docblock-short">Testing utilities.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.apply_method_all_arrow_series.html" title="macro polars::apply_method_all_arrow_series">apply_method_all_arrow_series</a></div></li><li><div class="item-name"><a class="macro" href="macro.df.html" title="macro polars::df">df</a></div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.VERSION.html" title="constant polars::VERSION">VERSION</a></div><div class="desc docblock-short">Polars crate version</div></li></ul></section></div></main></body></html>